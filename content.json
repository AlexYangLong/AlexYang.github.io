{"meta":{"title":"AlexYang's World","subtitle":"AlexYang的博客世界","description":"学习弯道超车的技巧！","author":"AlexYang","url":"http://alexyanglong.github.io"},"pages":[{"title":"分类","date":"2018-05-26T05:39:42.936Z","updated":"2018-05-26T05:39:42.936Z","comments":false,"path":"categories/index.html","permalink":"http://alexyanglong.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于Alex","date":"2018-05-26T05:31:34.709Z","updated":"2018-05-26T05:31:34.709Z","comments":false,"path":"about/index.html","permalink":"http://alexyanglong.github.io/about/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-05-26T05:49:45.810Z","updated":"2018-05-26T05:49:45.810Z","comments":false,"path":"tags/index.html","permalink":"http://alexyanglong.github.io/tags/index.html","excerpt":"","text":"tag: [test, test2]"}],"posts":[{"title":"Python第一阶段（二）","slug":"Python第一阶段（二）","date":"2018-05-26T06:31:53.465Z","updated":"2018-05-26T07:19:13.882Z","comments":true,"path":"2018/05/26/Python第一阶段（二）/","link":"","permalink":"http://alexyanglong.github.io/2018/05/26/Python第一阶段（二）/","excerpt":"","text":"Python第一阶段（二）函数定义函数，使用 def 关键字。 结构： 123def 函数名(参数列表...): 语句... return 返回值... 函数的参数： 1、不定长参数： *args 2、关键字参数：**kwargs 匿名函数: 关键字 lambda eg：qm = lambda x: x ** x 偏函数: 导入模块 import functools ​ functools.partical()就是创建一个新的函数，不需要自行定义函数，直接将结果赋值给一个变量，而这个变量就是一个函数。这个函数的目的是将默认参数给固定住。 回调函数：定义函数时,将函数名作为参数传递过来,然后在函数里边再次调用函数。 常用函数： abs(): 返回数字的绝对值max(): 返回给定参数中的最大值min():返回给定参数中最小的值pow(): 求幂(求次方) [求3^4 print(3**4) 、 print(pow(3, 4))]round():四舍五入,如果只有一个参数,默认不保留小数点.参数二: 小数点后保留的位数 import mathmath.ceil():向上取整math.floor():向下取整math.sqrt():求开方math.modf():返回参数的整数部分和小数部分 import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1)random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 变量作用域（LEGB）L （Local） 局部作用域 E （Enclosing） 闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域 装饰器本质还是函数, 一般使用装饰器来装饰其他函数。本身还是函数的调用。 @property@属性名.setter 广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：__iter()__ 和 next()。 字符串，列表或元组对象都可用于创建迭代器。 生成器yield 函数被称为生成器（generator）, 生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器 , 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 IO操作IO操作，使用open() 函数，还可以使用with上下文关键字来确保打开的文件操作符在退出时被关闭。 12with open(path, mode [, encoding]) as f: 操作... f.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。f.write() 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串f.close() 关闭文件f.readline([size]) 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数f.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).f.seek(偏移量,[起始位置]) 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 mode的模式： open()函数的mode方式详解 异常处理1234567891011try: try语句except 异常类1 as 变量1: 异常处理语句1except 异常类2 as 变量2: 异常处理语句2...[else: else语句][finally: finally语句] 操作文件和目录os模块:在这个模块中给我们封装好了系统操作的功能函数(方法)。 12345678910111213141516import osos.getcwd() # 返回当前的工作目录 # 获取绝对路径os.listdir(path) # 返回指定的文件夹包含的文件或文件夹的名字的列表os.mkdir(path) # 在当前目录下创建新的目录os.rmdir(path) # 删除目录, 只能删除空目录os.rename(src, dst) # 对文件进行重命名os.stat(file) # 获取文件属性os.remove(file) # 删除文件 #可以将本文件删除os.path.join(path1, path2) # 路径拼接os.path.split(path) # 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称)os.path.splitext(path) # 获取文件的或站名os.path.exists(path) # 判断文件/目录是否存在os.path.isfile(path) # 判断是否是文件os.path.getsize(file) # 获取文件的大小os.path.dirname(path) # 获取当前文件的目录os.path.basename(path) # 获取当前文件/目录名 StringIO很多时候，数据读写不一定是文件，也可以在内存中读写，而且更快。 1、StringIO模块主要用于在内存缓冲区中读写数据。模块是用类编写的，只有一个StringIO类，所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 123456789101112&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&apos;hello&apos;)5&gt;&gt;&gt; f.write(&apos; &apos;)1&gt;&gt;&gt; f.write(&apos;world!&apos;)6&gt;&gt;&gt; print(f.getvalue())hello world!**getvalue()**方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes。 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&apos;中文&apos;.encode(&apos;utf-8&apos;))6&gt;&gt;&gt; print(f.getvalue())b&apos;\\xe4\\xb8\\xad\\xe6\\x96\\x87&apos; 常用的日期和时间函数time(时间)time.localtime() 获取本地时间time.asctime() / time.ctime() 将时间转换成用户可读时间, 返回str格式 (Thu Apr 19 23:02:35 2018)time.strftime(&#39;%Y-%m-%d %X&#39;) 字符串的格式化输出, 返回str格式 (2018-04-19 23:07:51)time.strptime(timeObject, &#39;%Y-%m-%d %X&#39;) 将字符串的时间格式转换成元祖类型的时间格式 datetime(日期)datetime.datetime.now() 获取当前时间datetime.datetime(2020, 2, 2, 20, 20, 20) 获取指定的时间date1.strftime(&#39;%Y-%m-%d %X&#39;) 时间字符串的格式化输出, 返回str格式 calendar(日历)calendar.month(2018, 4) 获取指定的月份日历calendar.calendar(2018) 获取指定的年份日历 面向对象面向对象的三个基本特征是：封装、继承、多态。 封装：封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义：封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 ​ 1、保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 ​ 2、方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 ​ 3、当对象含有完整的属性和与之对应的方法时称为封装。 ​ 4、从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 ​ 5、对象的方法可以接收对象外面的消息。 继承：从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 ​ 1、在类名后边的括号里一般写的是基类的类名 ​ 2、子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 ​ 3、父类中私有的成员属性不能继承给子类的 多态：“一个接口，多种表现形式”。 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: ​ 1、继承的存在(继承是多态的基础,没有继承就没有多态) ​ 2、子类重写父类的方法(多态下调用子类重写的方法) ​ 3、父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象 一 找到和对象相关的数据一属性( 名词） @property @属性.setter __slots__ 限定自定义类型的对象只能绑定某些属性，可以通过在类中定义slots变量来进行限定。需要注意的是slots的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = (&apos;_name&apos;, &apos;_age&apos;, &apos;_gender&apos;) 行为抽象 一 找到和对象相关的行为一方法（动词） 成员方法：第一个参数为self，由实例化的对象调用 类方法：使用@classmethod装饰的方法是类方法，与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） 静态方法：使用@staticmethod装饰的方法是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 魔法方法：__init__() 、__del__() 、__str__() 、__repr__() 正则表达式 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记 网络编程协议- protocol- 通信双方对话的规范和标准 IP.Internet Protocol- 寻址和路由 www.baidu.com---&gt; 180.97.33.108 TCP和UDP是在IP协议之上构建的传输协议它们能够提供传输数据的服务 TCP提供了可靠传输服务 TCP- Transfer Control Protocol 握手机制+冗余校验—&gt; 重发一次 TCP. - Transfer Control Protocol 提供： ​ 1、可靠通信[数据不传丢也不传错] 滑动窗口机制 ​ 2、流量控制(自动调节发送数据的速度 ​ 3、拥塞控制(网络拥堵时会降低发送速度) QQ 微信.应用级 QQ— ICQ— OICQ HTTP— Hyper-Text Transfer Protocol HTTPS— Secure SMTP– Simple Mail Transfer Protocol POP3— Post Office Protocol version 3 IMAP—Internet Mail Access Protocol URL— Uniform Resource Locator 协议://域名或IP地址:80/路径/资源名 网络API(应用程序编程接口) / 网络 requests.get()用于请求目标网站，类型是一个HTTPresponse类型 12345678import requestsresponse = requests.get(&apos;http://www.baidu.com&apos;)print(response.status_code) # 打印状态码print(response.url) # 打印请求urlprint(response.headers) # 打印头信息print(response.cookies) # 打印cookie信息print(response.text) #以文本形式打印网页源码print(response.content) #以字节流形式打印 TCP编程Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。 服务器端程序： 12345678910111213141516171819202122232425262728293031from socket import socket, AF_INET, SOCK_STREAM, SOCK_DGRAMfrom datetime import datetimedef main(): # 1、创建套接字对象，并指定使用哪种传输服务 # AF_INET：IPV4 AF_INET6：IPV6 SOCK_STREAM: TCP SOCK_DGRAM: UDP SOCK_RAW: 原始套接字 server_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、绑定IP地址和端口，建议使用 1024 以后的端口 print(&apos;正在绑定IP地址和端口......&apos;) server_socket.bind((&apos;10.7.152.89&apos;, 9999)) print(&apos;服务器绑定IP地址和端口成功&apos;) # 3、启动监听 监听客户端有没有连接到服务器 512：历史经验最佳值 print(&apos;正在启动服务器......&apos;) server_socket.listen(512) print(&apos;服务器启动成功&apos;) # 4、等待连接 通过循环等待客户端连接并作出相应处理 while True: # 阻塞并等待连接 client_socket, addr = server_socket.accept() print(str(addr) + &apos;连接到了服务器.&apos;) # 5、发送数据 client_socket.send(str(datetime.now()).encode(&apos;utf-8&apos;)) # 6、断开连接 client_socket.close()if __name__ == &apos;__main__&apos;: main() 客户端程序： 123456789101112131415161718from socket import socket, AF_INET, SOCK_STREAMdef main(): # 1、创建套接字 socket client_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、连接服务器 client_socket.connect((&apos;10.7.152.89&apos;, 9999)) # 3、循环发送和接收信息 while True: info = client_socket.recv(1024).decode(&apos;utf-8&apos;) print(info) # client_socket.close()if __name__ == &apos;__main__&apos;: main() 多线程、多进程线程：是操作系统分配CPU的基本单元 进程：是操作系统分配内存的基本单元，一个进程由一个或多个线程构成 多进程、多线程：加速程序执行，提升性能；改善用户体验 ​ 编写麻烦，调试更麻烦；对其他进程、线程不友好；占用更多资源 单进程 / 单线程模拟下载任务例子： 单线程模拟下载例子 多进程模拟下载任务例子： 多进程模拟下载例子 多线程模拟下载任务例子： 多线程模拟下载例子","categories":[],"tags":[]},{"title":"Python第一阶段（一）","slug":"Python第一阶段（一）","date":"2018-05-26T05:55:03.798Z","updated":"2018-05-26T07:27:46.487Z","comments":true,"path":"2018/05/26/Python第一阶段（一）/","link":"","permalink":"http://alexyanglong.github.io/2018/05/26/Python第一阶段（一）/","excerpt":"","text":"Python第一阶段（一）变量在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： ​ 1、变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头； ​ 2、大小写敏感（大写的 a 和小写的 A 是两个不同的变量）； ​ 3、不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： ​ 1、用小写字母拼写，多个单词用下划线连接； ​ 2、受保护的实例属性用单个下划线开头； ​ 3、私有的实例属性用两个下划线开头。 当然，给变量（事实上应该是所有的标识符）命名做到见名知意也是非常重要的。 数据类型计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，部分如下： 整型（int）：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型（float）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型（str）：字符串是以单引号或双引号括起来的任意文本，比如&#39;hello&#39;和&quot;hello&quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型（bool）：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 复数型（complex）：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的 i 换成了 j 。 数据类型之间的转换： int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 运算符与表达式 运算符优先级 赋值表达式： 变量 = 表达式 表达式为真的情况: not 0 -1 等为真 表达式为假的情况: 0 &#39;&#39; None False [] () {} 小练习1、将华氏温度转换为摄氏温度 F = 1.8 * C + 32，F表示华氏温度，C表示摄氏温度 123f = float(input(&apos;请输入华氏温度: &apos;))c = (f - 32) / 1.8print(&apos;%.1f华氏度 = %.1f摄氏度&apos; % (f, c)) 2、输入圆的半径计算计算周长和面积 1234567import mathradius = float(input(&apos;请输入圆的半径: &apos;))perimeter = 2 * math.pi * radiusarea = math.pi * radius * radiusprint(&apos;周长: %.2f&apos; % perimeter)print(&apos;面积: %.2f&apos; % area) 3、输入年份判断是不是闰年，是则输出 True，否则输出 False 1234year = int(input(&apos;请输入年份: &apos;))# 如果代码太长写成一行不便于阅读 可以使用\\或()折行is_leap = (year % 4 == 0 and year % 100 != 0 or year % 400 == 0)print(is_leap) 列表 list列表是一个有序集合，下面是一些list的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# 创建一个空列表list1 = []print(list1)print(type(list1))# 创建带有元素的列表list2 = [1, 2, 3, 4, 5, 6, 7, 8]print(list2)# 列表元素的类型可以不同list3 = [12, &apos;qwe&apos;, 0.87, False, None]print(list3)# 访问列表中的元素 格式: 列表名[元素的下标] 注意：下标不能超出列表的范围，最大为len(list)-1list4 = [1, 2, 3, 4, 5, 6, 7, 8]print(list4[5])# 修改元素list4[3] = 10print(list4)# 列表的操作# 列表拼接list5 = [1, 2, 3, 4]list6 = [5, 6, 7]list7 = list5 + list6print(list7)# 列表的重复list8 = [4, 5, 6]print(list8 * 3)# 判断一个元素是否在列表中list9 = [1, 2, 3, 4, 5, 6]# 返回的结果是布尔值 存在为True 不存在为Falseprint(7 in list9)print(4 in list9)# 截取列表 list[start:end:step]list10 = [1, 2, 3, 4, 5, 6, 7, 8]print(list10[:6]) # 从左截取，从头开始，到下标为5的元素print(list10[5:]) # 从左截取，从下标为5的元素，到末尾print(list10[::-1]) # 将list倒序排列print(list10[::-2]) # 从右截取，末尾开始，每隔一个元素截取一个# 二维列表list11 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]# 获取元素print(list11[0][0])# 列表的方法# append(): 在列表的末尾添加一个元素list1 = [1, 2, 3, 4, 5, 6]list1.append(8)print(list1)list1.append([7, 9, 10])print(list1)# extend(): 在列表的末尾一次性追加另外一个列表中的多个值list2 = [1, 2, 3, 4, 5, 6]list2.extend([200, 300, 400])print(list2)#insert(index, val):在指定下标处添加一个元素,原来此处的元素往后移动 index：表示列表下标，val：表示下标对应的值list3 = [1, 2, 3, 4]list3.insert(1, 250)print(list3)# pop([index]):将列表中指定下标的元素删除, 如果不传递参数,则删除的是最后一个元素 index：表示列表下标，返回值：删除的该元素list4 = [1, 2, 3, 4, 5, 6]print(list4.pop())list4.pop()print(list4)list4.pop(1)print(list4)# remove(val): 移除列表中指定的元素，从左开始，移除第一个 val：表示列表中的值list5 = [3, 4, 5, 6, 3, 7]list5.remove(3)# list5.remove(3)print(list5)# clear(): 清除列表中所有的元素list6 = [1, 2, 3, 4, 5, 6]list6.clear()print(list6)# index(val): 获取列表中该元素所对应的下标 val：列表中的某一个元素 返回值：列表中元素所对应的下标list7 = [1, 2, 3, 4, 5, 6]index1 = list7.index(3)print(index1)# len(list): 获取列表的长度print(len([1, 2, 3, 4, 5, 6]))# max(list): 获取列表中的最大值print(max([1, 2, 3, 4, 5, 6]))# min(list): 获取列表中的最小值print(min([1, 2, 3, 4, 5, 6]))# count(val): 计算列表中元素出现的次数 val：列表中的某一个元素list8 = [1, 3, 4, 3, 3, 3, 3, 6, 7]print(list8.count(3))# reverse(): 将列表进行倒序排列list9 = [1, 2, 3, 4, 5, 10, 7, 8, 9]list9.reverse()print(list9)# sort(): 将列表中的元素进行升序排列list10 = [10, 90, 78, 23, 65, 43]list10.sort()print(list10)enumerate(list[, start = 0]):将列表中元素和其对应的下标一一展示出来# list: 列表# start: [start = 下标值]list16 = list(enumerate(list15))list17 = list(enumerate(list15, start = 1))print(list16)print(list17)# 循环遍历for i, v in list16: print(i, v) 元组 tuple元组：也是一种有序集合，但一旦定义好之后不能修改。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 创建一个空元祖tuple1 = ()print(tuple1)print(type(tuple1))# tuple和list一样也可以保存任意数据类型的数据tuple2 = (231, 323.14, &apos;asddf&apos;, None, True)print(tuple2)# 注意：当创建的元组只有一个元素时，需要在元素后面加一个逗号tuple3 = (34, ) # ===&gt; tuple类型 # tuple3 = (34) # ===&gt; int类型print(tuple3)# 获取元组的元素和list一样，通过下标来获取tuple4 = (1, 2, 3, 4, 5, 6)print(tuple4[-1])# 注意：元组定义好之后是不能修改的tuple5 = (1, 2, 3, 4, [11, 22, 33])# tuple5[0] = 150 # 报错print(tuple5[-1][-2]) # ==&gt; print(tuple5[4][1])# 元组进行操作# 将两个元组合并成一个新的元组tuple7 = (1, 2, 3)tuple8 = (4, 5, 6)tuple9 = tuple7 + tuple8print(tuple9)print(tuple7, tuple8)# 将元组重复n次,最后返回一个新的元组tuple10 = (1, 2, 3)print(tuple10 * 3)# in 判断一个元素是否在一个元组中,如果在返回True,否则返回Falsetuple11 = (3, 5, 7)print(3 in tuple11)print(4 in tuple11)# 元组的截取# 格式: 元组名[start:end:step]tuple12 = (1, 2, 3, 4, 5, 6, 7, 8, 9,10)print(tuple12[2:5])print(tuple12[3:])print(tuple12[:3])# 将元组进行逆序排列print(tuple12[::-1])# 二维元组tuple13 = ((2, 3, 4), (5, 6, 7))print(tuple13)print(tuple13[1][1])# 元组的方法# len(): 求一个元组的长度tuple14 = (1, 2, 3, 4, 5)print(len(tuple14))# max(): 求一个元组的元素的最大值print(max(tuple14))# min(): 求一个元组的元素的最小值print(min(tuple14))#遍历for i in tuple14: print(i) 字典 dict在字典里边是以键值对的形式存放。key-value注意事项:1、在字典中键(key)的值必须是唯一2、在字典中可以存放多个键值对3、在字典中键(key)必须是不可变类型 字符串 、整数都可以作为键(key)4、list和tuple都是有序集合, 而dict是无序集合 12345678910111213141516171819202122232425262728293031323334# 定义字典dict1 = &#123;&apos;Alex&apos;: 88, &apos;xiaoming&apos; : 99, &apos;Ala&apos;: 96, &apos;Tom&apos;: 85, &apos;Jhon&apos;: 77&#125;print(dict1)# 元素的访问# 获取的方式: 字典名[key]print(dict1[&apos;xiaoming&apos;])print(dict1.get(&apos;Alex&apos;))# 添加元素dict1[&apos;HanMeimei&apos;] = 89print(dict1)# 修改dict1[&apos;HanMeimei&apos;] = &apos;90&apos;print(dict1)# 删除dict1.pop(&apos;HanMeimei&apos;)print(dict1)# 遍历for k in dict1: print(k, dict1[k])# 获取字典所有的value和keyprint(dict1.values())print(dict1.keys())# 遍历value值for v in dict1.values(): print(v)#遍历key值for k in dict1.keys(): print(k)#遍历key-value值for k,v in dict1.items(): print(k, v)for k,v in enumerate(dict1): print(k, v) 集合 setset(集合):类似于dict, 也是无序的,以key的形式存在,没有value作用: 是对list ，tuple中的元素进行去重的, 求交集、并集1、set是无序集合2、set集合是不可改变的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 获取setset1 = set([1, 2, 2, 3, 3, 3])print(set1)print(type(set1))set2 = set((1, 2, 3, 1, 2, 3, 4, 5))print(set2)print(type(set2))set3 = set(&#123;3, 4, 5, 5, 6, 3, 7&#125;)print(set3)print(type(set3))# 添加set4 = set([1, 2, 2, 3, 3, 3])set4.add(55) # add() #可以添加重复的值,但是没效果# set4.add([10, 9]) #直接报错,不能添加listset4.add((10, 9))# set4.add(&#123;&apos;a&apos;:1&#125;) #直接报错,不能添加字典# 总结:list和dict是可改变的, 而tuple是不可改变print(set4)# 修改set5 = set([1, 2, 3, 4, 5])# 将list dict tuple 等等整个插入进去set5.update([6, 7, 8])set5.update(&#123;9 : &apos;a&apos;, 10 : &apos;b&apos;&#125;) #注意：插入字典时，是将key插进去set5.update((11, 56))print(set5)# 删除set6= set([1, 2, 3, 4, 5])set6.remove(4)print(set6)# 遍历set7 = set((231, 323.14, &apos;asddf&apos;, None, True))for i in set7: print(i)# 交集 &amp; 并集 | 差集 - 对称差 ^set8 = set([1, 2, 3, 4])set9 = set([3, 4, 5, 6])set10 = set8 &amp; set9set11 = set8 | set9print(set10)print(type(set10))print(set11)print(type(set11)) list、tuple、dict、set之间的转换12345678910111213141516171819202122232425262728293031323334#list-setlist1 = [1, 2, 3, 4, 4, 5, 5]set1 = set(list1)print(set1)print(type(set1))# set-&gt;listset2 = &#123;1, 2, 3, 4, 5, 6&#125;list2 = list(set2)print(list2)print(type(list2))# tuple-&gt;settuple1 = (1, 2, 3, 4, 5, 6, 6, 6)set3 = set(tuple1)print(set3)print(type(set3))# set-&gt;tupleset4 = &#123;1, 2, 3, 4, 5, 6&#125;tuple2 = tuple(set4)print(tuple2)print(type(tuple2))# dict-&gt;setdict1 = &#123;&apos;Alex&apos;: 88, &apos;xiaoming&apos; : 99, &apos;Ala&apos;: 96, &apos;Tom&apos;: 85, &apos;Jhon&apos;: 77&#125;set5 = set(dict1)print(set5)print(type(set5))# set-dict 注意：set不能转换成dict，因为set只有key，而dict是key-value形式存储的# set6 = &#123;2, 3, 4, 5&#125;# dict2 = dict(set6)# print(dict2) 流程控制：分支与循环分支在Python中，要构造分支结构可以使用if、elif和else关键字。 结构： 1234567if 表达式1: 语句1elif 表达式2: 语句2...else: 语句n 练习：英制单位与公制单位互换 12345678value = float(input(&apos;请输入长度:&apos;))unit = input(&apos;请输入单位:&apos;)if unit == &apos;in&apos; or unit == &apos;英寸&apos;: print(&apos;%f英寸 = %f厘米&apos; % (value, value * 2.54))elif unit == &apos;cm&apos; or unit == &apos;厘米&apos;: print(&apos;%f厘米 = %f英寸&apos; % (value, value / 2.54))else: print(&apos;请输入有效的单位&apos;) 循环构造循环语句要使用 for...in... 或者 while 关键字。 1、for...in...结构： 12for 变量 in 可迭代容器: 语句... eg：求1-100的和 1234sum = 0for x in range(101): sum += xprint(sum) 2、while结构： 12while 表达式： 语句... eg：猜数字游戏 ​ 规则：计算机出一个1~100之间的随机数由人来猜​ 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了 1234567891011121314151617import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input(&apos;请输入:&apos;)) if number &lt; answer: print(&apos;大一点&apos;) elif number &gt; answer: print(&apos;小一点&apos;) else: print(&apos;恭喜你猜对了!&apos;) breakprint(&apos;你总共猜了%d次&apos; % counter)if counter &gt; 7: print(&apos;你的智商余额明显不足&apos;) 练习：打印九九乘法表，要使用双层循环 1234for i in range(1, 10): for j in range(1, i + 1): print(&apos;%d*%d=%d&apos; % (i, j, i * j), end=&apos;\\t&apos;) print()","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python基础","slug":"Python基础","permalink":"http://alexyanglong.github.io/tags/Python基础/"},{"name":"list","slug":"list","permalink":"http://alexyanglong.github.io/tags/list/"},{"name":"tuple","slug":"tuple","permalink":"http://alexyanglong.github.io/tags/tuple/"},{"name":"dict","slug":"dict","permalink":"http://alexyanglong.github.io/tags/dict/"},{"name":"set","slug":"set","permalink":"http://alexyanglong.github.io/tags/set/"},{"name":"分支循环","slug":"分支循环","permalink":"http://alexyanglong.github.io/tags/分支循环/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-25T09:00:56.088Z","updated":"2018-05-26T05:48:09.982Z","comments":true,"path":"2018/05/25/hello-world/","link":"","permalink":"http://alexyanglong.github.io/2018/05/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 1tag: [test1, test2]","categories":[],"tags":[]}]}