{"meta":{"title":"AlexYang's World","subtitle":"AlexYang的博客世界","description":"学习弯道超车的技巧！","author":"AlexYang","url":"http://alexyanglong.github.io"},"pages":[{"title":"关于Alex","date":"2018-05-26T05:31:34.709Z","updated":"2018-05-26T05:31:34.709Z","comments":false,"path":"about/index.html","permalink":"http://alexyanglong.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-26T05:39:42.936Z","updated":"2018-05-26T05:39:42.936Z","comments":false,"path":"categories/index.html","permalink":"http://alexyanglong.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-05-26T09:07:53.258Z","updated":"2018-05-26T09:07:53.258Z","comments":false,"path":"tags/index.html","permalink":"http://alexyanglong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hexo快速搭建静态Blog网站","slug":"Hexo快速搭建静态Blog网站","date":"2018-05-28T09:30:07.661Z","updated":"2018-05-29T08:38:13.170Z","comments":true,"path":"2018/05/28/Hexo快速搭建静态Blog网站/","link":"","permalink":"http://alexyanglong.github.io/2018/05/28/Hexo快速搭建静态Blog网站/","excerpt":"","text":"Hexo快速搭建静态Blog网站声明：以下所有操作都是在windows操作系统下进行。 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装在安装Hexo前需要确保电脑已经安装以下程序 : Node.js Git 这两个程序的安装很简单，windows用户可以使用安装程序进行安装，简单高效。 安装Node.js建议使用这个下载地址，找到合适的版本进行下载安装即可，安装时的操作请自行参考百度。 安装Git建议使用这个下载地址 进行下载安装, 这里也请参考百度。建议不要下载最新的版本, 尽量下载大多数人用的版本。 安装Hexo在安装Hexo前，请再次确保Node.js和Git已经成功安装。检查是否安装好以上两个程序，在桌面点击鼠标右键，可在选项中看到 Git Bash Here 选项，点击进入bash交互界面。 在打开bash交互界面（类似于Linux交互界面）中输入： 1$ git --version 1$ node --version 如果显示相关的版本信息说明安装成功。 现在可以正式安装Hexo了，使用如下命令安装： 1$ npm install -g hexo-cli 建站初始化安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt; # folder 是文件夹 即 hexo init 文件夹$ cd &lt;folder&gt;$ npm install 命令执行成功没有 error 错误，我们就建站成功了。 ###安装hexo-server并启动 12$ npm install hexo-server --save$ hexo server 这两条命令执行完成后会生成一个如下的地址： 本地hexo-web地址 把这个网址复制下来并粘贴到浏览器中打开即可看到本地 Hexo 默认的主题博客了，如果没有成功的话请检查自己是否有操作不当的地方或者命令错误。 部署创建Git仓库登录GitHub账号，创建一个仓库，注意仓库的名字一定要以 “&lt;用户名&gt;.github.io” 这种格式。 hexo2 创建时，注意要将下面这个选项勾上。 hexo3 生成SSH keys这个很重要！ 这个如果没有添加 ssh keys 那么等会必定会报错。 使用如下操作生成SSH key hexo4 生成密钥完成后， 将 id_rsa.pub 中的所有内容拷贝到github中相应的位置中去。 登录GitHub，找到如下位置： hexo5 hexo6 hexo7 将生成的在 id_rsa.pub 中的内容 拷贝到其中，然后添加。 更改配置在初始化文件夹下找到 _config.yml 这个文件并打开 1$ vim _config.yml 打开后做如下修改， repository 就是 github 为我们生成的一个地址。这里注意一下空格。 hexo8 生成静态网页并部署123$ hexo clean # 清理缓存$ npm install hexo-deployer-git --save$ hexo g -d 至此，部署完毕。 最后在浏览器中输入地址即可（即 username.github.io ，其中username为你自己创建仓库的名字）。 当然在以上操作中如果遇到什么错误 这里也许可以帮到你 帮助 。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://alexyanglong.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://alexyanglong.github.io/tags/Hexo/"}]},{"title":"在Linux（CentOS7）下安装Redis","slug":"在Linux（CentOS7）下安装Redis","date":"2018-05-12T16:00:00.000Z","updated":"2018-06-05T02:10:03.261Z","comments":true,"path":"2018/05/13/在Linux（CentOS7）下安装Redis/","link":"","permalink":"http://alexyanglong.github.io/2018/05/13/在Linux（CentOS7）下安装Redis/","excerpt":"","text":"#在Linux（CentOS7）下安装Redis Redis是一款非关系型存储数据库。 ##1、下载软件归档压缩包 从redis官网上下载软件归档压缩包 1wget http://download.redis.io/releases/redis-3.2.11.tar.gz ##2、解压缩解归档 12gunzip redis-3.2.11.tar.gztar -xvf redis-3.2.11.tar.gz ##3、安装 切换至redis解压目录，执行下列命令进行配置和安装 1make &amp;&amp; make install ##4、配置redis.conf配置文件 配置redis.conf配置文件，注意备份 ###4.1、绑定ip 在命令模式下， 61gg 定位至61行，进行绑定ip [注意：使用内网ip，可以在末行模式下输入 :!ifconfig 查看内网ip] 4.2、配置端口在命令模式下， 84gg 定位至84行，配置端口，默认是 6379 4.3、配置连接密码在命令模式下输入 /requirepass 查找，按 n 查找下一个，大概在480行，修改后 保存退出 ##5、后台启动服务，并设置日志文件 1redis-server 配置文件的路径/配置文件名 &gt; 日志文件 &amp; 需要停止后台服务，请先把redis放在前台运行 (使用jobs查看后台运行编号num，再使用fg %num就将编号是num的服务放在前台运行了)，再使用 Ctrl C 停止redis服务。或者使用 kill 进程编号 同样，如果要将前台运行的服务放到后台运行，先使用Ctrl Z，再使用jobs查看状态，是处于Stopped停止状态，之后使用bg %num就可以将编号是num的服务放在后台运行了 基准测试 1redis-benchmark -h ip -p 端口 -a 密码 ##6、连接redis 123redis-cli -h ip [-p 端口号] - 端口号为默认的6379可以不写auth 密码 - 输入密码ping - 测试连接，回复pong成功","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"http://alexyanglong.github.io/tags/Redis/"}]},{"title":"在Linux（CentOS7）下安装MySQL5.x","slug":"在Linux（CentOS7）下安装MySQL5.x","date":"2018-05-11T16:00:00.000Z","updated":"2018-06-05T02:09:18.049Z","comments":true,"path":"2018/05/12/在Linux（CentOS7）下安装MySQL5.x/","link":"","permalink":"http://alexyanglong.github.io/2018/05/12/在Linux（CentOS7）下安装MySQL5.x/","excerpt":"","text":"在Linux（CentOS7）下安装MySQL5.xMySQL是一款数据库，用于存储数据。 ##1、先使用wget下载mysql安装包 1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz ##2、创建组、用户 后面mysql就使用这个用户来运行（注意这也是mysql启动脚本中默认的用户，因此最好不要改名）。 12groupadd mysqluseradd -r -g mysql mysql - （使用-r参数表示mysql用户是一个系统用户，不能登录） 3、安装3.1 解压将前面得到的mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压、解归档 12gunzip mysql-5.7.22-linux-glibc2.12-x86_64.tar.gztar -xvf mysql-5.7.22-linux-glibc2.12-x86_64.tar 将解压后的目录移动至 /usr/local ，并重命名为 mysql 1mv mysql-5.7.22-linux-glibc2.12-x86_64 /usr/local/mysql 此后 /usr/local/mysql 就是安装目录了 注意，如果mysql目录下没有data和tmp目录，手动新建，并修改权限 3.2 目录权限设置将mysql及其下所有的目录所有者和组均设为mysql 12cd /usr/local/mysqlchown mysql:mysql -R . 3.3 初始化1/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql 初始化成功后出现如下信息： 201x-xx-xxT07:10:13.583130Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use –explicit_defaults_for_timestamp server option (see documentation for more details). 201x-xx-xx T07:10:13.976219Z 0 [Warning] InnoDB: New log files created, LSN=45790 201x-xx-xx T07:10:14.085666Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 201x-xx-xx T07:10:14.161899Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 1fa941f9-effd-11e5-b67d-000c2958cdc8. 201x-xx-xx T07:10:14.165534Z 0 [Warning] Gtid table is not ready to be used. Table ‘mysql.gtid_executed’ cannot be opened. 201x-xx-xx T07:10:14.168555Z 1 [Note] A temporary password is generated for root@localhost: xxxxxxxxx. 注意最后一行，它给了root一个初始密码(xxxxxxxxx)，后面要登录的时候要用到这个密码。 ###3.4 配置 配置 /etc 下的 my.cnf 文件，如果没有请创建 12345678910[mysqld]basedir = /usr/local/mysqldatadir = /usr/local/mysql/dataport = 3306socket = /usr/local/mysql/tmp/mysql.sock sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client]socket = /usr/local/mysql/tmp/mysql.sock ##4、后台运行服务端 注意：请将{mysql} 替换成 您的mysql安装路径 1&#123;mysql&#125;/bin/mysqld_safe &amp; 使用ps -ef | grep mysql 或者 netstat -nap | grep 3306 - 查看进程 1&#123;mysql&#125;/bin/mysqladmin -uroot -p - 停止 如果出现错误，请检查前面几步是否出错。 ##5、设置mysql以服务运行并且开机启动 将{mysql}/ support-files/mysql.server 拷贝为/etc/init.d/mysql并设置运行权限 12cp mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysql 把mysql注册为开机启动的服务 1chkconfig --add mysql 当然也可以手动进行服务的开启和关闭： 12/etc/init.d/mysql start/etc/init.d/mysql stop 6、连接客户端创建客户端的软链接 1ln -s &#123;mysql&#125;/bin/mysql /usr/local/bin/mysql 客户端连接 1mysql -u root -p 输入刚才的初始化密码进入 进入之后，修改密码 1mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;您的新密码&apos;; 配置远程可以连接 123use mysql # 打开mysql数据库 update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;; # 将host设置为%表示任何ip都能连接mysql，当然也可以将host指定为某个ip flush privileges; # 刷新权限表，使配置生效 关闭远程连接，恢复mysql的默认设置（只能本地连接） 1update user set host=&apos;localhost&apos; where user=&apos;root&apos;; #将host设置为localhost表示只能本地连接mysql 也可以添加一个用户名为aaa，密码为xxx，权限为%（表示任意ip都能连接）的远程连接用户 1grant all on *.* to &apos;aaa&apos;@&apos;%&apos; identified by &apos;xxx&apos;; 至此，MySQL5.7安装完毕。 当然也可以使用Mariadb，它是MySQL5.x的一个分支，命令用法和MySQL5.x是一样的，安装（可以使用yum安装）步骤如下： 1、在安装之前可以先搜索yum管理工具中有没有mariadb的软件包，在命令行下： yum search mariadb-server mariadb 2、如果存在，就可以使用yum管理工具来安装，在命令行下： yum install mariadb-server mariadb 等待安装完成 4、启动/停止/重启数据库服务 systemctl start/stop/restart mariadb 设置开机自启 systemctl enable mariadb 取消开机自启 systemctl disable mariadb 4、连接数据库 mysql -u root -p","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://alexyanglong.github.io/tags/MySQL/"}]},{"title":"在Linux（CentOS7）下构建安装Python3.x","slug":"在Linux（CentOS7）下构建安装Python3.x","date":"2018-05-09T16:00:00.000Z","updated":"2018-06-05T02:08:14.439Z","comments":true,"path":"2018/05/10/在Linux（CentOS7）下构建安装Python3.x/","link":"","permalink":"http://alexyanglong.github.io/2018/05/10/在Linux（CentOS7）下构建安装Python3.x/","excerpt":"","text":"在Linux（CentOS7）下构建安装Python3.xLinux环境自带了Python 2.x版本，但是如果要使用3.x的版本，可以先在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。 1、安装依赖库因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败 1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 2、下载Python源代码并解压缩到指定目录123wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xzxz -d Python-3.6.1.tar.xztar -xvf Python-3.6.1.tar 3、配置和安装先切换至Python源代码目录并执行下面的命令进行配置和安装。 123cd Python-3.6.1./configure --prefix=/usr/local/python36 --enable-optimizationsmake &amp;&amp; make install ##4、创建软链接 这样就可以直接通过python3直接启动Python解释器，pip管理工具，2to3转换工具。 123ln -s /usr/local/python36/bin/python3 /usr/bin/python3ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3ln -s /usr/local/python36/bin/2to3 /usr/bin/2to3 ##5、测试 123python3 - 进入python3.X的交互环境pip3 -V - 查看pip的版本2to3 - 查看2to3 如果没有报错，就安装成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"}]},{"title":"在Linux（CentOS7）下安装Nginx服务器","slug":"在Linux（CentOS7）下安装Nginx服务器","date":"2018-05-09T16:00:00.000Z","updated":"2018-06-05T02:08:30.006Z","comments":true,"path":"2018/05/10/在Linux（CentOS7）下安装Nginx服务器/","link":"","permalink":"http://alexyanglong.github.io/2018/05/10/在Linux（CentOS7）下安装Nginx服务器/","excerpt":"","text":"在Linux（CentOS7）下安装Nginx服务器nginx是一款高性能的web服务器，在Linux中可以使用 yum 来安装，安装步骤如下： 1、检查yum包管理工具中有没有Nginx1yum search nginx 2、安装1yum install nginx 3、启动nginx服务器1nginx - 如果没有报错，就OK 4、测试在浏览器地址栏输入主机公网ip，进行测试查看。注意：先确保主机的80端口[web服务默认80端口]是开启的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://alexyanglong.github.io/tags/Nginx/"}]},{"title":"Linux Shell的基本使用","slug":"Linux的基本使用","date":"2018-05-04T16:00:00.000Z","updated":"2018-06-05T02:07:22.128Z","comments":true,"path":"2018/05/05/Linux的基本使用/","link":"","permalink":"http://alexyanglong.github.io/2018/05/05/Linux的基本使用/","excerpt":"","text":"#Linux Shell的基本使用 Linux简介 操作系统发展史图： 操作系统发展史 ##Linux的基本命令（centos7） who 或 w：查看当前登录的所有用户 who am i 或 whoami：查看当前登录用户 last：查看之前登录过的用户历史记录 clear：清屏 ps：查看进程状态 ​ ps -ef：查看进程 ​ ps -aux：查看进程 kill ： 进程号：杀掉进程 netstat -nap：查看进程、端口、进程号 adduser 用户名：创建新用户 userdel 用户名：删除用户 passwd [用户名]：修改用户密码，不加用户名是修改的root的密码 ssh 用户名@ip地址：远程安全连接其他的服务器 logout 或 exit：退出 reboot：重启服务器 shutdown：关闭服务器 init 0：关机 init 6：重启 uname：查看当前系统 hostname：查看主机名 history：查看历史命令，默认保存最近1000条，可以使用 HISTSIZE=新值 来修改保存的条数 ​ !num(命令行号)：重新执行改行命令 man 命令：查看’命令‘的使用方式 info 命令：查看’命令‘的使用方式，更详细 命令 --help：查看’命令‘的参数使用方法 whatis 命令：查看命令的简短描述 pwd：打印当前工作目录路径 - print working directory whereis 命令：查找包含 ’命令‘ 所有的目录路径 which 命令：查找到第一个含有 ’命令‘ 的目录路径 su 用户名：切换到该用户，但是不会切换到该用户的文件目录 su - 用户名：切换到该用户，并且切换到该用户的文件目录 sudo 命令操作：以管理员身份执行 mkdir 目录名：创建目录 rmdir 目录名：删除空目录 rm 目录名/文件名：删除目录或者文件，可以加参数 ​ -i：交互式删除，有提示 interactive ​ -f：不用提示，直接删除 force ​ -r：递归删除目录下的内容 recursive ls：查看当前目录下的所有文件和目录（非隐藏），可以加参数 ​ -l：查看当前目录下的所有文件和目录，长格式（非隐藏） ​ -a：查看当前目录下的所有文件和目录 ​ -al 或 -l -a：查看当前目录下的所有文件和目录，长格式 ​ -r：反转显示目录下的文件和目录，按字母表降序 ​ -R：递归显示目录下的文件和目录 touch 文件名：没有该文件就创建一个空文件，有只是改变其时间戳，可以修改文件的三个时间：修改内容的时间，更改权限的时间，最后访问的时间 cd 目录：切换目录 - change directory ​ cd /root：回到root主目录 （/root 绝对路径） （/root：root用户主目录，/etc：放置配置文件目录 /home：其他用户的用户主目录，/usr：用户数据、用户应用目录） ​ cd ~：回到当前用户主目录 ​ cd ..：回到上一级 ​ cd /：回到根目录 cp 文件名 路径：将文件拷贝到路径下，可以重命名 scp 本地文件 用户名@ip地址:路径：将本地文件安全拷贝到目标服务器的某路径下 sftp 用户名@ip地址：安全的远程文件传输 mv 文件名/目录 路径：将文件/目录剪切（移动）到路径下，可以重命名 cat 文件名：查看文件所有内容 ​ cat 文件名 -n：查看文件内容并显示行号 ​ cat 文件名| more 或 less：一页一页查看 ​ cat 文件名| grep pattern：搜索文件中的内容，匹配模式pattern匹配的字符串 head -n 文件：查看文件前 n 行 tail -n 文件：查看文件最后 n 行 wget 资源路径：联网获取资源 ​ wget -O filename 资源路径：获取资源并给资源重命名 grep pattern 文件1：搜索文件1中的内容，匹配模式pattern匹配的字符串 find：查找文件或目录 jobs：查看正在执行的后台任务列表 fg %n：将编号为 n 的后台任务拿到前台执行 bg %n：将编号为 n 的后台暂停任务继续在后台执行 top：查看CPU的状态 wc 文件：统计文件的行数、单词数、字符数，可以加参数 ​ -l：行数 ​ -w：单词数 uniq 文件：将文件中的内容去重显示，注意只能去相邻的重复的，不改变原文件内容 sort 文件：将文件中的内容进行排序显示，不改变原文件内容 diff 文件1 文件2：比较两个文件的差异，并显示不同之处 file 文件：显示文件的性质 date：查看当前时间 cal：查看日历 echo：回声命令 ​ echo string：在屏幕上输出string ​ echo string &gt; 文件：将string输出到文件中 ​ echo $a：在屏幕上打印变量a的值 ln：创建链接 ln 路径1/文件1 路径2/文件2：给路径1下的文件1在路径2下创建名为文件2的硬链接，存储的是文件1内容的引用，相当于备份，但是不会占用空间 ln -s 路径1/文件1 路径2/文件2：给路径1下的文件1在路径2下创建名为文件2的软链接，相当于快捷方式，不是引用 gzip 文件名：压缩 gunzip 文件名：解压缩 xz：压缩、解压缩，可以加参数 ​ xz -z 文件名：压缩 ​ -0 … -9：压缩比，值越大，压缩率越大 ​ xz -d 文件名：解压缩 tar：归档 ​ -x：抽取，解归档 ​ -v：显示解归档的过程 ​ -f：指定文件名 ​ tar -xvf 文件名：解归档使用 ​ -t：查看归档文件的内容 ​ -c：归档 ​ tar -cvf 归档文件名 源文件路径：归档使用 alias 名称=&#39;命令 [参数]&#39;：给 ‘命令 参数’ 起别名 unalias 名称：取消别名 !v：把刚刚以v开头的命令在执行一遍 &amp;：后台执行 >文件2：输出重定向，将运行结果输出到文件2 2&gt; 文件3：错误重定向，将错误输出到文件3 >&gt; 文件4：追加输出重定向，将运行结果追加输出到文件4 &lt;：输入重定向 ##vi / vim 编辑器的使用： i 或 a：进入编辑模式 ESC：退出编辑模式，进入命令模式 : ：在命令模式下，按 : 键进入末行模式 ###在命令模式下： yy：复制本行 num yy：复制num行 p：粘贴 dd：删除本行 num dd：删除num行 dw：删除一个单词 dG：删除所有内容 d$：从当前位置删除到行末尾 u：撤销 G：去到最后一行 num G：去到num行 gg：回到第一行 Ctrl y：向上翻一行 Ctrl e：向下翻一行 Ctrl f：向下翻一页 Ctrl b：向上翻一页 ZZ：保存并退出 ###在末行模式下： :!系统命令：在vim编辑器执行系统命令，执行完后回车，回到vim编辑器 eg： :!cal :wq：保存并退出 :q!：不保存退出 :set nu：显示行号 :set nonu：取消行号 :syntax off：关闭高亮语法 :syntax on：开启高亮语法 :set ts=4：将制表键设置为4个空格 /string：搜索string， 按 n 键向下搜索， 按 N 键向上搜索 :1,$s/string1/string2/g：将文件中从第一行到最后一行的所有string1换成string2 :inoremap 快捷键名 对应的代码 ：自定义快捷键 eg： :inoremap pymain if name == ‘main‘ ##文件、目录权限： - rwx rwx rwx: 类型 所有者权限 同组用户权限 其他用户权限 类型：文件（-）、目录（d）、链接（l） r：read 4 - 0b(100) w：write 2 - 0b(10) x：excute 1 - 0b(1) chmod 权限 文件/目录：修改文件/目录的权限 chmod 777 文件/目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"}]},{"title":"JavaScript总结","slug":"JavaScript总结","date":"2018-04-27T16:00:00.000Z","updated":"2018-06-05T02:06:32.794Z","comments":true,"path":"2018/04/28/JavaScript总结/","link":"","permalink":"http://alexyanglong.github.io/2018/04/28/JavaScript总结/","excerpt":"","text":"#JavaScript总结 JavaScript： JS - Behavior ​ ECMAScript - 语法规范 - ES5 ​ BOM - 浏览器对象模型 - window ​ DOM - 文档对象模型 - document ##JavaScript 数据类型 JavaScript 有隐式的类型转换。 ​ 简单数据类型： number、string、boolean、null、undefined ​ 复杂数据类型： object ​ 可以使用 typeof() 查看数据类型 ##JavaScript 运算符 ​ 算术运算符：+ 、-、 *、/、 % 、**（ES7版本） ​ 赋值运算符：= 、+=、 -=、 *=、 /=、%= ​ 比较（关系）运算符： &gt;、 &gt;=、 &lt;、 &lt;=、 ==、 != 、===（不带隐式类型转换的等于，全等于）、!==（严格不等于） ​ 逻辑运算符： &amp;&amp;（短路与）、 ||（短路或）、 ! ​ 自增自减运算符： ++ 、-- ​ 位运算、成员运算 ##JavaScript 中的全局函数 isNaN() 判断是不是 不是一个数 parseInt() 取整，如果取不出，返回NaN parseFloat() 取小数，如果取不出，返回NaN isFinite() 判断是不是有限的数 eval() - evaluate - 容易引发XSS（跨站脚本攻击） encodeURIcomponent() 编成 百分号 编码 decodeURIcomponent() 从百分号编码 解码 ##获取对象 获取的对象元素： document.getElementById(#id) document.getElementByClassName(.class) document.getElementByTagName(标签) querySelector() ： 根据指定的选择器查找单个元素 querySelectorAll() ： 根据指定的选择器查找所有元素 this // this 表示引发当前事件的对象元素 // evt 表示当前事件，evt.target 表示引发当前事件的事件源 // 需要在函数参数中 传入evt 对象 evt = evt || window.event; // 兼容低版本的IE var target = evt.target || evt.srcElement; 在定义函数时，如果没有传入参数，那么函数中有一个隐藏的 arguments 对象，它代表了参数的列表，在调用时，可以传入任意多个参数。 12345function foo()&#123; for (var i = 0;i &lt; arguments.length;i++)&#123; alert(arguments[i]); &#125;&#125; ##window对象 document 文档 location 地址栏 - href / reload / replace history 历史记录 - go / forward / back navigator 浏览器 screen 操作系统窗口 - availWidth/ availHeight / width / height alert /confirm / prompt open / close setTimeout / setInterval / clearTimeout / clearInterval 修改节点的内容和属性 textContent innerHTML nodeValue 访问成员运算符 . setAttribute / getAttribute / removeAttribute 创建新节点 createElement 追加新节点 appendChild insertBefore 移除子节点 removeChild 通过自己节点访问父节点 parentNode 通过自己节点访问子节点 children 所有 firstChild 第一个 lastChild 最后一个 通过自己节点访问兄弟节点 nextSibling 前面的兄弟 prevSibling 后面的兄弟 JQueryjQuery的$函数的作用: 1、$(function() {}) $() 函数传入的是一个函数，表示该函数是在页面加载完成之后要执行的回调函数 2、$(selector) $() 函数传入的是一个选择器，表示通过选择器获得对应的元素，并处理成 jQuery对象，jQuery对象的本质是一个数组，如果要将jQuery对象转成原生js对象，使用下标或者get() 运算 3、$(element) $() 函数传入的是一个原生js对象，表示将其转成jQuery对象 4、$(标签) $() 函数传入的是一个标签，表示创建对应的元素并处理成jQuery对象 注意：当jQuery库和其他的库中的 $函数 有冲突，可以使用以下方法解决： ​ jQuery.noConflict() 将jQuery库中的 $函数 不起作用，但是jQuery库可以使用jQuery来替代 $，其他库可以使用 $函数。 ###查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector)/ :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(&#39;…&#39;)/ :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=&#39;value&#39;] / [attribute!=&#39;value&#39;] / [attribute^=&#39;value&#39;] / [attribute$=&#39;value&#39;] / [attribute|=&#39;value&#39;] / [attribute~=&#39;value&#39;] 表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked ###执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() AJAX - Asynchronous JavaScript and XML让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷新，这样就可以在不中断用户体验的前提下刷新页面数据 123456789101112$.ajax(&#123; url: 向服务器发送请求的url type: 发送请求的类型（get、post、put、patch、delete等） data: 发送请求时需要向服务器提交的数据，不是必填项 datatype: 接收服务器返回数据的类型 success: function(data)&#123; 执行成功时，回调的函数 &#125;, error: function(error)&#123; 执行失败时，回调的函数 &#125;&#125;);","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://alexyanglong.github.io/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://alexyanglong.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://alexyanglong.github.io/tags/jQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://alexyanglong.github.io/tags/AJAX/"}]},{"title":"HTML+CSS总结","slug":"HTML+CSS总结","date":"2018-04-24T16:00:00.000Z","updated":"2018-06-05T02:05:33.676Z","comments":true,"path":"2018/04/25/HTML+CSS总结/","link":"","permalink":"http://alexyanglong.github.io/2018/04/25/HTML+CSS总结/","excerpt":"","text":"HTML+CSS总结Web前端主要包含三部分内容： 1、Tag：HTML标签，用来装要显示的内容、数据。 2、CSS：Display，对要显示的内容进行渲染。 3、JavaScript：Behavior，交互、行为，使用户具有更好的体验。 HTML​ HTML （Hyper Text Markup Language，超文本标记语言）是用来描述网页的一种语言，它包含了一系列的标签。 ​ html：此标签可告知浏览器其自身是一个 HTML 文档。&lt;html&gt; 与 &lt;/html&gt; 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。 ​ head：此标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。下面这些标签可用在 head 部分：&lt;base&gt; 、&lt;link&gt; 、&lt;meta&gt; 、&lt;style&gt; 、&lt;script&gt; 和 &lt;title&gt; 。&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 ​ body：此标签定义文档的主体。包含文档的所有要进行显示的内容（比如文本&lt;span&gt; &lt;p&gt; 、上标&lt;sup&gt; 、下标&lt;sub&gt; 、超链接&lt;a&gt;、图像&lt;img&gt;、表格&lt;table&gt; 、列表&lt;ul&gt; &lt;ol&gt; &lt;dl&gt; 、逻辑语义块&lt;header&gt; &lt;section&gt; &lt;aside&gt; &lt;footer&gt; &lt;div&gt; 、标题&lt;h1&gt;~&lt;h6&gt; 、换行&lt;br&gt; 、内嵌块&lt;iframe&gt; 、表单元素&lt;form&gt; &lt;input&gt; &lt;button&gt; &lt;select&gt; 、音频&lt;audio&gt; 、视频&lt;video&gt;等等）。 ​ 除此之外，每个标签都有自己特有的属性，例如&lt;a&gt; 标签有href属性、每个标签都有的class属性等等。并且还支持自定义属性，即开发人员自己定义一个不存在的属性。 CSS​ CSS（Cascading Style Sheets，层叠样式表）是用来渲染HTML标签的显示样式的一种语言。根据CSS在HTML页面的位置的不同，可以分为三类： ​ 内部样式表：写在&lt;head&gt;的&lt;style&gt;标签内，多用于首页。加载快。 ​ 外部样式表：脱离HTML页面，写在外部，可以用于其他页面。所有页面可以共享同一个样式，便于风格统一；使内容和显示分离。 ​ 内嵌（行内）样式表：写在每个标签的style属性内，不常用。不易于扩展。 CSS选择器通配符选择器： * 标签选择器： &lt;标签名&gt; 类选择器： .class id选择器： #id 并列选择器：selector1 , selector2 后代选择器： 父 空格(所有后代)、父&gt;(儿子后代) 兄弟选择器： ~ (所有兄弟) 相邻兄弟选择器： + (必须是相邻兄弟) 标签使用哪个CSS样式进行渲染的三个原则：​ 1、就近原则： 哪个样式里标签更近就用哪个 ​ 2、具体性原则： #id选择器 &gt; .class选择器 &gt; 标签选择器 &gt; 通配符选择器 ​ 3、重要性原则： !important CSS盒子模型CSS模型：Box Model （盒模型 ） —— 由内到外： 内容 - padding - border - background-image - background-color - margin 标签常用的CSS样式边框border 设置对象边框的特性 border-color 设置或检索对象的边框颜色 字体font-size 设置字体大小 font-family 规定文本的字体 font-style 规定文本的字体样式 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果 ####内外边距 padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-top padding-right padding-bottom padding-left margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 margin-top margin-right margin-bottom margin-left ####背景 background-color 设置或检索对象的背景颜色 background-image 设置或检索对象的背景图像 ####display display: none 此元素不会被显示。 display: block 此元素将显示为块级元素，此元素前后会带有换行符。 display: inline 此元素会被显示为内联元素，元素前后没有换行符。 display: inline-block 此元素会被显示为行内块元素，可以设置宽度、高度等，元素前后没有换行符。 具有hidden 属性的元素是不可见的。 CSS 定位：position: static 正常文档流 position: relative 相对定位（相对于元素原来的位置，没有脱离文档流，对周围元素没有影响） position: absolute 绝对定位（相对于父元素来设定位置，脱离了文档流，对周围元素有影响） position: fixed 固定定位（相对于浏览器窗口来设定位置，脱离了文档流） CSS 设置字符集@charset : utf-8 CSS 设置字体： 1234@font-face &#123; font-family： ‘字体名称’ src：url(字体资源路径)&#125; CSS hack technology （CSS黑科技）z-index 索引，当脱离文档流时，元素显示优先级冲突，设置元素z-index属性值越大就渲染在越上方 在有浮动的情况下 ，为了让父级元素计算出它的高度的方法： 1、clear:both 清除浮动 2、在父元素的样式中加入 overflow：auto","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://alexyanglong.github.io/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://alexyanglong.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://alexyanglong.github.io/tags/CSS/"}]},{"title":"Python基础（14）——进程和线程","slug":"Python基础（14）——进程和线程","date":"2018-04-19T16:00:00.000Z","updated":"2018-06-05T02:05:10.727Z","comments":true,"path":"2018/04/20/Python基础（14）——进程和线程/","link":"","permalink":"http://alexyanglong.github.io/2018/04/20/Python基础（14）——进程和线程/","excerpt":"","text":"Python基础（14）——进程和线程线程：是操作系统分配CPU的基本单元 进程：是操作系统分配内存的基本单元，一个进程由一个或多个线程构成 多进程、多线程：加速程序执行，提升性能；改善用户体验 ​ 编写麻烦，调试更麻烦；对其他进程、线程不友好；占用更多资源 单进程 / 单线程模拟下载任务例子： 单线程模拟下载例子 多进程模拟下载任务例子： 多进程模拟下载例子 多线程模拟下载任务例子： 多线程模拟下载例子","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://alexyanglong.github.io/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://alexyanglong.github.io/tags/进程/"}]},{"title":"Python基础（13）——网络编程入门","slug":"Python基础（13）——网络编程入门","date":"2018-04-16T16:00:00.000Z","updated":"2018-06-05T02:04:54.066Z","comments":true,"path":"2018/04/17/Python基础（13）——网络编程入门/","link":"","permalink":"http://alexyanglong.github.io/2018/04/17/Python基础（13）——网络编程入门/","excerpt":"","text":"Python基础（13）——网络编程入门基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 TCP提供了可靠地数据传输，主要基于以下机制： ​ 1、可靠通信[数据不传丢也不传错] 滑动窗口机制 ​ 2、流量控制(自动调节发送数据的速度 ​ 3、拥塞控制(网络拥堵时会降低发送速度) 服务器端程序： 12345678910111213141516171819202122232425262728293031from socket import socket, AF_INET, SOCK_STREAM, SOCK_DGRAMfrom datetime import datetimedef main(): # 1、创建套接字对象，并指定使用哪种传输服务 # AF_INET：IPV4 AF_INET6：IPV6 SOCK_STREAM: TCP SOCK_DGRAM: UDP SOCK_RAW: 原始套接字 server_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、绑定IP地址和端口，建议使用 1024 以后的端口 print('正在绑定IP地址和端口......') server_socket.bind(('10.7.152.89', 9999)) print('服务器绑定IP地址和端口成功') # 3、启动监听 监听客户端有没有连接到服务器 512：历史经验最佳值 print('正在启动服务器......') server_socket.listen(512) print('服务器启动成功') # 4、等待连接 通过循环等待客户端连接并作出相应处理 while True: # 阻塞并等待连接 client_socket, addr = server_socket.accept() print(str(addr) + '连接到了服务器.') # 5、发送数据 client_socket.send(str(datetime.now()).encode('utf-8')) # 6、断开连接 client_socket.close()if __name__ == '__main__': main() 客户端程序： 123456789101112131415161718from socket import socket, AF_INET, SOCK_STREAMdef main(): # 1、创建套接字 socket client_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、连接服务器 client_socket.connect(('10.7.152.89', 9999)) # 3、循环发送和接收信息 while True: info = client_socket.recv(1024).decode('utf-8') print(info) # client_socket.close()if __name__ == '__main__': main() UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"TCP编程","slug":"TCP编程","permalink":"http://alexyanglong.github.io/tags/TCP编程/"},{"name":"套接字编程","slug":"套接字编程","permalink":"http://alexyanglong.github.io/tags/套接字编程/"}]},{"title":"Python基础（12）——正则表达式","slug":"Python基础（12）——正则表达式","date":"2018-04-14T16:00:00.000Z","updated":"2018-06-05T02:04:39.062Z","comments":true,"path":"2018/04/15/Python基础（12）——正则表达式/","link":"","permalink":"http://alexyanglong.github.io/2018/04/15/Python基础（12）——正则表达式/","excerpt":"","text":"Python基础（12）——正则表达式正则的基本符号下面的表示总结了一些正则的基本符号： 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://alexyanglong.github.io/tags/正则表达式/"},{"name":"re模块","slug":"re模块","permalink":"http://alexyanglong.github.io/tags/re模块/"}]},{"title":"Python基础（11）——面向对象基础","slug":"Python基础（11）——面向对象基础","date":"2018-04-11T16:00:00.000Z","updated":"2018-06-05T02:04:09.104Z","comments":true,"path":"2018/04/12/Python基础（11）——面向对象基础/","link":"","permalink":"http://alexyanglong.github.io/2018/04/12/Python基础（11）——面向对象基础/","excerpt":"","text":"Python基础（11）——面向对象基础在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象的三个基本特征是：封装、继承、多态。 封装封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义：封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 ​ 1、保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 ​ 2、方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 ​ 3、当对象含有完整的属性和与之对应的方法时称为封装。 ​ 4、从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 ​ 5、对象的方法可以接收对象外面的消息。 继承从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 ​ 1、在类名后边的括号里一般写的是基类的类名 ​ 2、子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 ​ 3、父类中私有的成员属性不能继承给子类的 多态“一个接口，多种表现形式”。 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: ​ 1、继承的存在(继承是多态的基础,没有继承就没有多态) ​ 2、子类重写父类的方法(多态下调用子类重写的方法) ​ 3、父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象 一 找到和对象相关的数据——属性( 名词），可以使用包装器@property和修改器@属性.setter来装饰属性。 __slots__限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = (&apos;_name&apos;, &apos;_age&apos;, &apos;_gender&apos;) 行为抽象 一 找到和对象相关的行为——方法（动词） 成员方法：第一个参数为self，由实例化的对象调用 类方法：使用@classmethod装饰的方法是类方法，与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） 静态方法：使用@staticmethod装饰的方法是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 魔法方法：__init__() 、__del__() 、__str__() 、__repr__()","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://alexyanglong.github.io/tags/面向对象/"}]},{"title":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO","slug":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO","date":"2018-04-09T16:00:00.000Z","updated":"2018-06-05T02:03:55.453Z","comments":true,"path":"2018/04/10/Python基础（10）——文件IO、异常处理、StringIO、BytesIO/","link":"","permalink":"http://alexyanglong.github.io/2018/04/10/Python基础（10）——文件IO、异常处理、StringIO、BytesIO/","excerpt":"","text":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO文件IOIO操作，使用open() 函数，还可以使用with上下文关键字来确保打开的文件操作符在退出时被关闭。 12with open(path, mode [, encoding]) as f: 操作... f.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。f.write() 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串f.close() 关闭文件f.readline([size]) 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数f.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).f.seek(偏移量,[起始位置]) 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 mode模式： open()函数的mode方式详解 os模块12345678910111213141516import osos.getcwd() # 返回当前的工作目录 # 获取绝对路径os.listdir(path) # 返回指定的文件夹包含的文件或文件夹的名字的列表os.mkdir(path) # 在当前目录下创建新的目录os.rmdir(path) # 删除目录, 只能删除空目录os.rename(src, dst) # 对文件进行重命名os.stat(file) # 获取文件属性os.remove(file) # 删除文件 #可以将本文件删除os.path.join(path1, path2) # 路径拼接os.path.split(path) # 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称)os.path.splitext(path) # 获取文件的或站名os.path.exists(path) # 判断文件/目录是否存在os.path.isfile(path) # 判断是否是文件os.path.getsize(file) # 获取文件的大小os.path.dirname(path) # 获取当前文件的目录os.path.basename(path) # 获取当前文件/目录名 异常处理在Python中处理异常使用try...except...[else...][finally...]关键字。 格式： 1234567891011try: try语句except 异常类1 as 变量1: 异常处理语句1except 异常类2 as 变量2: 异常处理语句2...[else: else语句][finally: finally语句] 执行顺序：进入try语句块，如果发生错误，依次匹配except中的异常类，匹配成功进入该异常处理块，如果不报错，会执行else中的语句，而finally不管有没有报错都会执行… 1234567891011121314151617def div(x , y): try: res = x / y except ZeroDivisionError as e: print('除数不能为0') else: print(res) finally: print('Anyway，I always run') def main(): div(10, 0)if __name__ == '__main__': main() StringIO很多时候，数据读写不一定是文件，也可以在内存中读写，而且更快。 StringIO模块主要用于在内存缓冲区中读写数据。它只有一个StringIO类，所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 123456789101112&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world!# getvalue() 方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，先创建一个BytesIO对象，然后写入一些bytes。 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"文件IO","slug":"文件IO","permalink":"http://alexyanglong.github.io/tags/文件IO/"},{"name":"异常处理","slug":"异常处理","permalink":"http://alexyanglong.github.io/tags/异常处理/"},{"name":"StringIO","slug":"StringIO","permalink":"http://alexyanglong.github.io/tags/StringIO/"},{"name":"BytesIO","slug":"BytesIO","permalink":"http://alexyanglong.github.io/tags/BytesIO/"}]},{"title":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域","slug":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域","date":"2018-04-07T16:00:00.000Z","updated":"2018-06-05T02:03:30.427Z","comments":true,"path":"2018/04/08/Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域/","link":"","permalink":"http://alexyanglong.github.io/2018/04/08/Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域/","excerpt":"","text":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域函数定义函数，使用 def 关键字。 结构： 123def 函数名(参数列表...): 语句... return 返回值... 函数的参数： 1、不定长参数： *args 2、关键字参数：**kwargs 匿名函数: 关键字 lambda eg：qm = lambda x: x ** x 偏函数: 导入模块 import functools ​ functools.partical()就是创建一个新的函数，不需要自行定义函数，直接将结果赋值给一个变量，而这个变量就是一个函数。这个函数的目的是将默认参数给固定住。 回调函数：定义函数时，将函数名作为参数传递过来，然后在函数里边再次调用函数。 常用函数： abs(): 返回数字的绝对值max(): 返回给定参数中的最大值min():返回给定参数中最小的值pow(): 求幂(求次方) [求3^4 —&gt; print(3**4) 、 print(pow(3, 4))]round():四舍五入,如果只有一个参数,默认不保留小数点.参数二: 小数点后保留的位数 import mathmath.ceil():向上取整math.floor():向下取整math.sqrt():求开方math.modf():返回参数的整数部分和小数部分 import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1)random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 import time time.localtime() 获取本地时间time.asctime() / time.ctime() 将时间转换成用户可读时间, 返回str格式 (Thu Apr 19 23:02:35 2018)time.strftime(&#39;%Y-%m-%d %X&#39;) 字符串的格式化输出, 返回str格式 (2018-04-19 23:07:51)time.strptime(timeObject, &#39;%Y-%m-%d %X&#39;) 将字符串的时间格式转换成元祖类型的时间格式 import datetime datetime.datetime.now() 获取当前时间datetime.datetime(2020, 2, 2, 20, 20, 20) 获取指定的时间date1.strftime(&#39;%Y-%m-%d %X&#39;) 时间字符串的格式化输出, 返回str格式 import calendar calendar.month(2018, 4) 获取指定的月份日历calendar.calendar(2018) 获取指定的年份日历 装饰器本质还是函数（闭包函数）， 一般使用装饰器来装饰其他函数。本身还是函数的调用。 12345678910111213141516171819202122232425\"\"\"装饰器:1.在定义函数时,将函数名作为参数来传递2.自定义一个装饰器,(即自定义一个函数),在函数内部去调用真正的函数3.return 装饰器的自调\"\"\"def outer(func): def inner(): print('装饰器....') func() print('啦啦啦....') return inner@outer # --&gt; func1 = outer(func1)def func1(): print('1234567')func1()\"\"\"输出：装饰器....1234567啦啦啦....\"\"\" 例如 @property 、@属性名.setter 广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：__iter()__ 和 next()。 字符串，列表或元组对象都可用于创建迭代器。 生成器yield 函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器， 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 变量作用域（LEGB）L （Local） 局部作用域 E （Enclosing） 嵌套作用域，闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"http://alexyanglong.github.io/tags/函数/"},{"name":"装饰器","slug":"装饰器","permalink":"http://alexyanglong.github.io/tags/装饰器/"},{"name":"迭代器","slug":"迭代器","permalink":"http://alexyanglong.github.io/tags/迭代器/"},{"name":"生成器","slug":"生成器","permalink":"http://alexyanglong.github.io/tags/生成器/"},{"name":"变量作用域","slug":"变量作用域","permalink":"http://alexyanglong.github.io/tags/变量作用域/"}]},{"title":"Python基础（8）——常见的字符串函数","slug":"Python基础（8）——常见的字符串函数","date":"2018-04-04T16:00:00.000Z","updated":"2018-06-05T02:03:08.617Z","comments":true,"path":"2018/04/05/Python基础（8）——常见的字符串函数/","link":"","permalink":"http://alexyanglong.github.io/2018/04/05/Python基础（8）——常见的字符串函数/","excerpt":"","text":"常见的字符串函数1、splitsplit(str=’ ‘[,num]) 对字符串进行切片，并返回一个列表，str 表示按此字符串进行分割，默认是空格，num 表示最多分割多少次 12str1 = 'aaa sss ddd 'print(str1.split(' ', 3)) # ['aaa', 'sss', 'ddd', ''] 2、splitlinessplitlines([keepends=False]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符，默认是False 123456str2 = '''aaaaaaaaaassssssssssssssssssdddddddd'''print(str2.splitlines(keepends=True)) # ['aaaaaaaaaa\\n', 'ssssssssssssssssss\\n', 'dddddddd\\n']print(str2.splitlines(keepends=False)) # ['aaaaaaaaaa', 'ssssssssssssssssss', 'dddddddd'] 3、joinjoin() 用于将序列中的元素以指定的字符连接生成一个新的字符串 1234str3 = 'asdfghj'list = ['a','s','e']print('-'.join(list)) # 'a-s-e'print('-'.join(str3)) # 'a-s-d-f-g-h-j' 4、maxmax() 返回给定参数的最大ASCII值的字符，参数可以为序列 1print(max('asdfghj')) # 's' 5、minmax() 返回字符串中最小ASCII值的字符 1print(min('asdfghj')) # 'a' 6、replacereplace(old, new[, max]) 把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次 1print('asdfghjkasasas'.replace('a', '1', 2)) # '1sdfghjk1sasas' 7、maketrans、translatemaketrans() 返回字符串转换后生成的新字符串 translate(table) 返回按照table中给出的映射来进行翻译后的字符串 12trantab = str.maketrans('abcd', '1234')print('asdfghjkasasas'.translate(trantab)) # '1s4fghjk1s1s1s' 8、startswith startswith(str, beg=0,end=len(string)) 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查 12print('asdfghjkasasas'.startswith('asd')) # Trueprint('asdfghjkasasas'.startswith('asd', 2, 10)) # False 9、endswithendswith(suffix[, start[, end]]):方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置 1print('asdfghjkasasas'.endswith('ghj', 0, 7)) # True 10、encodeencode() 指定的编码格式编码字符串。默认编码为 ‘utf-8’。 1print('asdfg'.encode('utf-8')) # b'asdfg' 11、decodedecode():以指定的编码格式解码 bytes 对象。默认编码为 ‘utf-8’。 1print(('asdfg'.encode('utf-8')).decode('utf-8')) # 'asdfg' 12、isalphaisalpha():方法检测字符串是否只由字母组成 1print('asdfg12'.isalpha()) # False 13、isalnumisalnum():检测字符串是否由字母和数字组成 1print('123456asd'.isalnum()) # True 14、isupperisupper():检测字符串中所有的字母是否都为大写 1print('ASDFGd'.isupper()) # False 15、islowerislower():检测字符串是否由小写字母组成 1print('Asdfghjkrt5'.islower()) # False 16、istitleistitle():检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写 1print('My Name Is Alex'.istitle()) # True 17、isdigitisdigit():检测字符串是否只由数字组成 1print('12345678'.isdigit()) # True 18、isnumericisnumeric():检测字符串是否只由数字组成。这种方法是只针对unicode对象 1print('1234567'.isnumeric()) # True 19、isdecimalisdecimal():检查字符串是否只包含十进制字符。这种方法只存在于unicode对象 1print('12345'.isdecimal()) # True 20、isspaceisspace():检测字符串是否只由空白字符组成 1print(' '.isspace()) # True 21、lenlen():返回对象（字符、列表、元组等）长度或项目个数 1print(len('asdfghj234567')) # 13 22、lowerlower():转换字符串中所有大写字符为小写 1print('ASDasdfgerty3456'.lower()) # 'asdasdfgerty3456' 23、upperupper():将字符串中的小写字母转为大写字母 1print('ASDasdfgerty3456'.upper()) # 'ASDASDFGERTY3456' 24、swapcaseswapcase():用于对字符串的大小写字母进行转换 1print('ASDasdfgerty3456'.swapcase()) # 'asdASDFGERTY3456' 25、capitalizecapitalize():将字符串的第一个字母变成大写,其他字母变小写 1print('asd WERtsd3456'.capitalize()) # 'Asd wertsd3456' 26、titletitle():返回”标题化”的字符串,就是说所有单词都是以大写开始 1print('my name is Alex'.title()) # 'My Name Is Alex' 27、centercenter(width[, fillchar]):返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格 1print('asd1'.center(10, ' ')) # ' asd1 ' 28、ljustljust(width[, fillchar]):返回一个原字符串左对齐,并使用fillchar填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串 1print('asd1'.ljust(10, ' ')) # 'asd1 ' 29、rjustrjust(width[, fillchar]):回一个原字符串右对齐,并使用fillchar填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串 1print('asd1'.rjust(10, ' ')) # ' asd1' 30、zfillzfill(width):返回指定长度的字符串，原字符串右对齐，前面填充0 1print('asd1'.zfill(10)) # '000000asd1' 31、countcount():统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置 1print('aaaaaaaqwertya'.count('a')) # 8 32、findfind():方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定子字符串，返回的是子字符串在字符串中的起始位置（下标）。如果不包含，返回-1 1print('asdfghjkl'.find('fg1')) # -1 33、rfindrfind():返回字符串最后一次出现的位置（下标），如果没有匹配项则返回-1 1print('asdfghjklfg'.rfind('fg')) # 9 34、indexindex():方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法相似，但是没有匹配项时，报错。 12print('asdfghjkl'.index('fg')) # 3print('asdfghjkl'.index('fg1')) # ValueError: substring not found 35、rindexrindex():返回子字符串 str 在字符串中最后出现的位置（下标），该方法与 python rfind()方法相似，但是没有匹配项时，报错。 12print('asdfghjklfg'.rindex('fg')) # 9print('asdfghjkl'.rindex('fg1')) # ValueError: substring not found 36、stripstrip():用于移除字符串头尾指定的字符（默认为空格） 1print(' asd '.strip()) # 'asd' 37、lstriplstrip():方法用于截掉字符串左边的空格或指定字符（默认为空格） 1print(' asd '.lstrip()) # 'asd ' 38、rstriprstrip():删除 string 字符串末尾的指定字符（默认为空格） 1print(' asd '.rstrip()) # ' asd'","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"字符串函数","slug":"字符串函数","permalink":"http://alexyanglong.github.io/tags/字符串函数/"}]},{"title":"Python基础（7）——流程控制：分支与循环","slug":"Python基础（7）——流程控制：分支与循环","date":"2018-04-02T16:00:00.000Z","updated":"2018-06-05T02:02:22.284Z","comments":true,"path":"2018/04/03/Python基础（7）——流程控制：分支与循环/","link":"","permalink":"http://alexyanglong.github.io/2018/04/03/Python基础（7）——流程控制：分支与循环/","excerpt":"","text":"流程控制：分支与循环流程控制语句主要分为三种： ​ 1、顺序语句：顾名思义，就是按照顺序从头一句一句往下执行。 ​ 2、分支语句 ​ 3、循环语句 分支语句在Python中，要构造分支结构可以使用if、elif和else关键字。 结构： 1234567if 表达式1: 语句1elif 表达式2: 语句2[...]else: 语句n 执行顺序：先判断表达式1 的值，如果为True ，则执行语句1 ，然后结束分支。如果为False ，则判断表达式2 的值，如果为True ，则执行语句2 ，然后结束分支。[…] 如果所有的表达式都为False ，则执行else中的语句n 。 练习：英制单位与公制单位互换 12345678value = float(input('请输入长度:'))unit = input('请输入单位:')if unit == 'in' or unit == '英寸': print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米': print('%f厘米 = %f英寸' % (value, value / 2.54))else: print('请输入有效的单位') 循环语句构造循环语句要使用 for...in... 或者 while 关键字。 1、for...in...结构，依次把可迭代容器中的每个元素迭代出来 12for 变量 in 可迭代容器: 语句... eg：求1-100的和 1234sum = 0for x in range(101): sum += xprint(sum) 2、while结构，只要条件满足，就不断循环，条件不满足时退出循环。 12while 表达式： 语句... eg：猜数字游戏 ​ 规则：计算机出一个1~100之间的随机数由人来猜​ 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了，当猜的次数大于7，再提示智商不足 1234567891011121314151617import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入:')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter)if counter &gt; 7: print('你的智商余额明显不足') 练习：打印九九乘法表，要使用双层循环 1234for i in range(1, 10): for j in range(1, i + 1): print('%d*%d=%d' % (i, j, i * j), end='\\t') print()","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"分支循环","slug":"分支循环","permalink":"http://alexyanglong.github.io/tags/分支循环/"}]},{"title":"Python基础（6）——list、tuple、dict、set之间的转换","slug":"Python基础（6）——list、tuple、dict、set之间的转换","date":"2018-04-01T16:00:00.000Z","updated":"2018-06-05T02:02:01.305Z","comments":true,"path":"2018/04/02/Python基础（6）——list、tuple、dict、set之间的转换/","link":"","permalink":"http://alexyanglong.github.io/2018/04/02/Python基础（6）——list、tuple、dict、set之间的转换/","excerpt":"","text":"Python基础（6）——list、tuple、dict与set之间的转换list、tuple、dict与set之间的转换list和tuple是有序的，dict和set是无序的。 list和dict是可变的，tuple和set是“不可变的”。 dict具有极快的查找速度，不会因为元素个数的增多而变慢，相应的，占用的空间大； 而list占用的空间较小，但是查找速度会随着元素个数的增多而变慢。 12345678910111213141516171819202122232425262728293031323334#list-&gt;setlist1 = [1, 2, 3, 4, 4, 5, 5]set1 = set(list1)print(set1)print(type(set1))# set-&gt;listset2 = &#123;1, 2, 3, 4, 5, 6&#125;list2 = list(set2)print(list2)print(type(list2))# tuple-&gt;settuple1 = (1, 2, 3, 4, 5, 6, 6, 6)set3 = set(tuple1)print(set3)print(type(set3))# set-&gt;tupleset4 = &#123;1, 2, 3, 4, 5, 6&#125;tuple2 = tuple(set4)print(tuple2)print(type(tuple2))# dict-&gt;setdict1 = &#123;'Alex': 88, 'xiaoming' : 99, 'Ala': 96, 'Tom': 85, 'Jhon': 77&#125;set5 = set(dict1)print(set5)print(type(set5))# set-dict 注意：set不能转换成dict，因为set只有key，而dict是key-value形式存储的# set6 = &#123;2, 3, 4, 5&#125;# dict2 = dict(set6)# print(dict2)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"list","slug":"list","permalink":"http://alexyanglong.github.io/tags/list/"},{"name":"tuple","slug":"tuple","permalink":"http://alexyanglong.github.io/tags/tuple/"},{"name":"set","slug":"set","permalink":"http://alexyanglong.github.io/tags/set/"},{"name":"dict","slug":"dict","permalink":"http://alexyanglong.github.io/tags/dict/"}]},{"title":"Python基础（5）——集合set","slug":"Python基础（5）——集合set","date":"2018-04-01T16:00:00.000Z","updated":"2018-06-05T02:01:41.712Z","comments":true,"path":"2018/04/02/Python基础（5）——集合set/","link":"","permalink":"http://alexyanglong.github.io/2018/04/02/Python基础（5）——集合set/","excerpt":"","text":"Python基础（5）——集合set集合setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 作用: 一般是对list ，tuple中的元素进行去重的，求交集、并集、差集等 set的一些常用操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 获得setset1 = set([1, 2, 2, 3, 3, 3])print(set1)print(type(set1))set2 = set((1, 2, 3, 1, 2, 3, 4, 5))print(set2)print(type(set2))set3 = set(&#123;3, 4, 5, 5, 6, 3, 7&#125;)print(set3)print(type(set3))# 添加set4 = set([1, 2, 2, 3, 3, 3])set4.add(55) # add() #可以添加重复的值,但是没效果# set4.add([10, 9]) #直接报错,不能添加listset4.add((10, 9))# set4.add(&#123;'a':1&#125;) #直接报错,不能添加字典# 总结:list和dict是可改变的, 而tuple是不可改变print(set4)# 修改set5 = set([1, 2, 3, 4, 5])# 将list dict tuple 等等整个插入进去set5.update([6, 7, 8])set5.update(&#123;9 : 'a', 10 : 'b'&#125;) #注意：插入字典时，是将key插进去set5.update((11, 56))print(set5)# 删除set6= set([1, 2, 3, 4, 5])set6.remove(4)print(set6)# 遍历set7 = set((231, 323.14, 'asddf', None, True))for i in set7: print(i)# 交集 &amp; 并集 | 差集 - 对称差 ^set8 = set([1, 2, 3, 4])set9 = set([3, 4, 5, 6])set10 = set8 &amp; set9set11 = set8 | set9print(set10)print(type(set10))print(set11)print(type(set11))","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"set","slug":"set","permalink":"http://alexyanglong.github.io/tags/set/"}]},{"title":"Python基础（4）——字典dict","slug":"Python基础（4）——字典dict","date":"2018-03-31T16:00:00.000Z","updated":"2018-06-05T02:01:22.483Z","comments":true,"path":"2018/04/01/Python基础（4）——字典dict/","link":"","permalink":"http://alexyanglong.github.io/2018/04/01/Python基础（4）——字典dict/","excerpt":"","text":"Python基础（4）——字典dict字典dictPython内置了字典：dict的支持，dict全称dictionary，使用键-值（key-value）存储，具有极快的查找速度。 注意事项:​ 1、在字典中键(key)的值必须是唯一​ 2、在字典中可以存放多个键值对​ 3、在字典中键(key)必须是不可变类型，字符串 、整数等都可以作为键(key) 下面是字典dict的一些常用操作： 12345678910111213141516171819202122232425262728293031323334# 定义字典dict1 = &#123;'Alex': 88, 'xiaoming' : 99, 'Ala': 96, 'Tom': 85, 'Jhon': 77&#125;print(dict1)# 元素的访问# 获取的方式: 字典名[key]print(dict1['xiaoming'])print(dict1.get('Alex'))# 添加元素dict1['HanMeimei'] = 89print(dict1)# 修改dict1['HanMeimei'] = '90'print(dict1)# 删除dict1.pop('HanMeimei')print(dict1)# 遍历for k in dict1: print(k, dict1[k])# 获取字典所有的value和keyprint(dict1.values())print(dict1.keys())# 遍历value值for v in dict1.values(): print(v)#遍历key值for k in dict1.keys(): print(k)#遍历key-value值for k,v in dict1.items(): print(k, v)for k,v in enumerate(dict1): print(k, v)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"dict","slug":"dict","permalink":"http://alexyanglong.github.io/tags/dict/"}]},{"title":"Python基础（3）——元组tuple","slug":"Python基础（3）——元组tuple","date":"2018-03-30T16:00:00.000Z","updated":"2018-06-05T02:01:03.102Z","comments":true,"path":"2018/03/31/Python基础（3）——元组tuple/","link":"","permalink":"http://alexyanglong.github.io/2018/03/31/Python基础（3）——元组tuple/","excerpt":"","text":"Python基础（3）——元组tuple元组tuplePython还有另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。 下面是元组tuple的一些常见操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 创建一个空元祖tuple1 = ()print(tuple1)print(type(tuple1))# tuple和list一样也可以保存任意数据类型的数据tuple2 = (231, 323.14, 'asddf', None, True)print(tuple2)# 注意：当创建的元组只有一个元素时，需要在元素后面加一个逗号tuple3 = (34, ) # ===&gt; tuple类型 # tuple3 = (34) # ===&gt; int类型print(tuple3)# 获取元组的元素和list一样，通过下标来获取tuple4 = (1, 2, 3, 4, 5, 6)print(tuple4[-1])# 注意：元组定义好之后是不能修改的tuple5 = (1, 2, 3, 4, [11, 22, 33])# tuple5[0] = 150 # 报错print(tuple5[-1][-2]) # ==&gt; print(tuple5[4][1])# 元组进行操作# 将两个元组合并成一个新的元组tuple7 = (1, 2, 3)tuple8 = (4, 5, 6)tuple9 = tuple7 + tuple8print(tuple9)print(tuple7, tuple8)# 将元组重复n次,最后返回一个新的元组tuple10 = (1, 2, 3)print(tuple10 * 3)# in 判断一个元素是否在一个元组中,如果在返回True,否则返回Falsetuple11 = (3, 5, 7)print(3 in tuple11)print(4 in tuple11)# 元组的截取# 格式: 元组名[start:end:step]tuple12 = (1, 2, 3, 4, 5, 6, 7, 8, 9,10)print(tuple12[2:5])print(tuple12[3:])print(tuple12[:3])# 将元组进行逆序排列print(tuple12[::-1])# 二维元组tuple13 = ((2, 3, 4), (5, 6, 7))print(tuple13)print(tuple13[1][1])# 元组的方法# len(): 求一个元组的长度tuple14 = (1, 2, 3, 4, 5)print(len(tuple14))# max(): 求一个元组的元素的最大值print(max(tuple14))# min(): 求一个元组的元素的最小值print(min(tuple14))#遍历for i in tuple14: print(i)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"tuple","slug":"tuple","permalink":"http://alexyanglong.github.io/tags/tuple/"}]},{"title":"Python基础（2）——列表list","slug":"Python基础（2）——列表list","date":"2018-03-29T16:00:00.000Z","updated":"2018-06-05T02:00:33.285Z","comments":true,"path":"2018/03/30/Python基础（2）——列表list/","link":"","permalink":"http://alexyanglong.github.io/2018/03/30/Python基础（2）——列表list/","excerpt":"","text":"Python基础（2）——列表list列表listPython还内置了一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 下面是列表list的一些常见操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# 创建一个空列表list1 = []print(list1)print(type(list1))# 创建带有元素的列表list2 = [1, 2, 3, 4, 5, 6, 7, 8]print(list2)# 列表元素的类型可以不同list3 = [12, 'qwe', 0.87, False, None]print(list3)# 访问列表中的元素 格式: 列表名[元素的下标] 注意：下标不能超出列表的范围，最大为len(list)-1，超出下标会报一个IndexError错误list4 = [1, 2, 3, 4, 5, 6, 7, 8]print(list4[5])# 修改元素list4[3] = 10print(list4)# 列表的操作# 列表拼接list5 = [1, 2, 3, 4]list6 = [5, 6, 7]list7 = list5 + list6print(list7)# 列表的重复list8 = [4, 5, 6]print(list8 * 3)# 判断一个元素是否在列表中list9 = [1, 2, 3, 4, 5, 6]# 返回的结果是布尔值 存在为True 不存在为Falseprint(7 in list9)print(4 in list9)# 截取列表 list[start:end:step]list10 = [1, 2, 3, 4, 5, 6, 7, 8]print(list10[:6]) # 从左截取，从头开始，到下标为5的元素print(list10[5:]) # 从左截取，从下标为5的元素，到末尾print(list10[::-1]) # 将list倒序排列print(list10[::-2]) # 从右截取，末尾开始，每隔一个元素截取一个# 二维列表list11 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]# 获取元素print(list11[0][0])# 列表的方法# append(): 在列表的末尾添加一个元素list1 = [1, 2, 3, 4, 5, 6]list1.append(8)print(list1)list1.append([7, 9, 10])print(list1)# extend(): 在列表的末尾一次性追加另外一个列表中的多个值list2 = [1, 2, 3, 4, 5, 6]list2.extend([200, 300, 400])print(list2)#insert(index, val):在指定下标处添加一个元素,原来此处的元素往后移动 index：表示列表下标，val：表示下标对应的值list3 = [1, 2, 3, 4]list3.insert(1, 250)print(list3)# pop([index]):将列表中指定下标的元素删除, 如果不传递参数,则删除的是最后一个元素 index：表示列表下标，返回值：删除的该元素list4 = [1, 2, 3, 4, 5, 6]print(list4.pop())list4.pop()print(list4)list4.pop(1)print(list4)# remove(val): 移除列表中指定的元素，从左开始，移除第一个 val：表示列表中的值list5 = [3, 4, 5, 6, 3, 7]list5.remove(3)# list5.remove(3)print(list5)# clear(): 清除列表中所有的元素list6 = [1, 2, 3, 4, 5, 6]list6.clear()print(list6)# index(val): 获取列表中该元素所对应的下标 val：列表中的某一个元素 返回值：列表中元素所对应的下标list7 = [1, 2, 3, 4, 5, 6]index1 = list7.index(3)print(index1)# len(list): 获取列表的长度print(len([1, 2, 3, 4, 5, 6]))# max(list): 获取列表中的最大值print(max([1, 2, 3, 4, 5, 6]))# min(list): 获取列表中的最小值print(min([1, 2, 3, 4, 5, 6]))# count(val): 计算列表中元素出现的次数 val：列表中的某一个元素list8 = [1, 3, 4, 3, 3, 3, 3, 6, 7]print(list8.count(3))# reverse(): 将列表进行倒序排列list9 = [1, 2, 3, 4, 5, 10, 7, 8, 9]list9.reverse()print(list9)# sort(): 将列表中的元素进行升序排列list10 = [10, 90, 78, 23, 65, 43]list10.sort()print(list10)# enumerate(list[, start = 0]):将列表中元素和其对应的下标一一展示出来# list: 列表# start: [start = 下标值]list16 = list(enumerate(list15))list17 = list(enumerate(list15, start = 1))print(list16)print(list17)# 循环遍历for i, v in list16: print(i, v)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"list","slug":"list","permalink":"http://alexyanglong.github.io/tags/list/"}]},{"title":"Python基础（1）——数据类型与基础语法","slug":"Python基础（1）——数据类型与基础语法","date":"2018-03-27T16:00:00.000Z","updated":"2018-06-05T01:57:20.327Z","comments":true,"path":"2018/03/28/Python基础（1）——数据类型与基础语法/","link":"","permalink":"http://alexyanglong.github.io/2018/03/28/Python基础（1）——数据类型与基础语法/","excerpt":"","text":"Python基础（1）——数据类型与基础语法数据类型计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，部分如下： 整型（int）：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型（float）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型（str）：字符串是以单引号或双引号括起来的任意文本，比如&#39;hello&#39;和&quot;hello&quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型（bool）：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 空值类型（None）：表示变量的值为None。 复数型（complex）：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的 i 换成了 j 。 数据类型之间的转换： int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 变量在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： ​ 1、变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头； ​ 2、大小写敏感（小写的 a 和大写的 A 是两个不同的变量）； ​ 3、不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： ​ 1、用小写字母拼写，多个单词用下划线连接； ​ 2、受保护的实例属性用单个下划线开头； ​ 3、私有的实例属性用两个下划线开头。 当然，给变量（标识符）命名做到见名知意也是非常重要的。 运算符与表达式 运算符优先级 赋值表达式： 变量 = 表达式 表达式为真的情况: not 0 -1 等为真 表达式为假的情况: 0 &#39;&#39; None False [] () {} 格式化输出Python中，在使用print()函数在进行打印输出时，可以format()和% 占位符格式化输出字符串。 常见的%占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12print('%2d-%02d' % (3, 1)) # --&gt; 3-01print('%.2f' % 3.1415926) # --&gt; 3.14 有些时候，字符串里面的%是一个普通字符，这个时候就需要转义，用%%来表示一个%： 1print('the rate: %d %%' % 7) # --&gt; the rate: 7 % 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 1print('Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)) # Hello, 小明, 成绩提升了 17.1% 注释注释分为单行注释和多行注释。 单行注释直接在要注释的行前面加# 1# 这是一行单行注释 多行注释可以使用用&#39;&#39;&#39;或&quot;&quot;&quot;开头，&#39;&#39;&#39;或&quot;&quot;&quot;结尾 1234567891011'''这也是多行注释这也是多行注释...'''\"\"\"这里是多行注释这里是多行注释...\"\"\" 小练习1、将华氏温度转换为摄氏温度 F = 1.8 * C + 32，F表示华氏温度，C表示摄氏温度 123f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 2、输入圆的半径计算计算周长和面积 1234567import mathradius = float(input('请输入圆的半径: '))perimeter = 2 * math.pi * radiusarea = math.pi * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area) 3、输入年份判断是不是闰年，是则输出 True，否则输出 False 12345year = int(input('请输入年份: '))# 如果代码太长写成一行不便于阅读 可以使用\\或()折行is_leap = (year % 4 == 0 and year % 100 != 0 \\ or year % 400 == 0)print(is_leap)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"http://alexyanglong.github.io/tags/数据类型/"},{"name":"基础语法","slug":"基础语法","permalink":"http://alexyanglong.github.io/tags/基础语法/"}]}]}