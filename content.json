{"meta":{"title":"AlexYang's World","subtitle":"AlexYang的博客世界","description":"学习弯道超车的技巧！","author":"AlexYang","url":"http://alexyanglong.github.io"},"pages":[{"title":"关于Alex","date":"2018-05-26T05:31:34.709Z","updated":"2018-05-26T05:31:34.709Z","comments":false,"path":"about/index.html","permalink":"http://alexyanglong.github.io/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-05-26T05:39:42.936Z","updated":"2018-05-26T05:39:42.936Z","comments":false,"path":"categories/index.html","permalink":"http://alexyanglong.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签云","date":"2018-05-26T09:07:53.258Z","updated":"2018-05-26T09:07:53.258Z","comments":false,"path":"tags/index.html","permalink":"http://alexyanglong.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Flask -- 第一个Flask项目","slug":"Flask -- 第一个Flask项目","date":"2018-06-03T16:00:00.000Z","updated":"2018-06-25T09:35:43.519Z","comments":true,"path":"2018/06/04/Flask -- 第一个Flask项目/","link":"","permalink":"http://alexyanglong.github.io/2018/06/04/Flask -- 第一个Flask项目/","excerpt":"","text":"Flask – 第一个Flask项目Flask简介Flask是一个基于Python实现的web开发的’微‘框架。 Flask和Django一样，也是一个基于MVC设计模式的Web框架。 flask流行的主要原因： 123a）有非常齐全的官方文档，上手非常方便b) 有非常好的拓展机制和第三方的拓展环境，工作中常见的软件都有对应的拓展，自己动手实现拓展也很容易c) 微型框架的形式给了开发者更大的选择空间 安装flask打开黑屏终端，执行命令。 创建虚拟环境12345virtualenv --no-site-packages falskenv# 激活windows下虚拟环境cd Scriptsactivate 安装1pip install flask 基于flask的最小的应用创建项目目录 1mkdir hello_flask 进入项目目录，创建hello.py文件 12345678910from flask import Flaskapp = Flask(__name__)@app.route(&apos;/&apos;)def hello_world(): return &apos;Hello World&apos;if __name__ == &apos;__main__&apos;: app.run() 在黑屏终端中运行：python hello.py hello.py文件说明： a) 初始化应用程序： 123from flask import Flaskapp = Flask(__name__) Flask类构造函数唯一需要的参数就是应用程序的主模块或包。对于大多数应用程序，Python的name变量就是那个正确的、你需要传递的值。Flask使用这个参数来确定应用程序的根目录，这样以后可以相对这个路径来找到资源文件。 b) 路由： 1@app.route(&apos;/&apos;) 客户端例如web浏览器发送 请求 给web服务，进而将它们发送给Flask应用程序实例。应用程序实例需要知道对于各个URL请求需要运行哪些代码，所以它给Python函数建立了一个URLs映射。这些在URL和函数之间建立联系的操作被称之为 路由 。 在Flask应程序中定义路由的最便捷的方式是通过显示定义在应用程序实例之上的app.route装饰器，注册被装饰的函数来作为一个 路由。 c) 视图函数： 在上一个示例给应用程序的根URL注册hello_world()函数作为事件的处理程序。如果这个应用程序被部署在服务器上并绑定了 www.example.com 域名，然后在你的浏览器地址栏中输入 http://www.example.com 将触发hello_world()来运行服务。客户端接收到的这个函数的返回值被称为 响应 。如果客户端是web浏览器，响应则是显示给用户的文档。 类似于hello_world()的函数被称作 视图函数 。 d) 动态名称组件路由： Flask在路由装饰器中使用特殊的语法支持这些类型的URLs。下面的示例定义了一个拥有动态名称组件的路由： 123@app.route(&apos;/hello/&lt;name&gt;&apos;)def hello_world(name): return &apos;Hello World %s&apos; % name 用尖括号括起来的部分是动态的部分，所以任何URLs匹配到静态部分都将映射到这个路由。当视图函数被调用，Flask发送动态组件作为一个参数。在前面的示例的视图函数中，这个参数是用于生成一个个性的问候作为响应。 在路由中动态组件默认为字符串，但是可以定义为其他类型。例如，路由/user/int:id只匹配有一个整数在id动态段的URLs。Flask路由支持int、float 如下： 123@app.route(&apos;/hello/&lt;int:id&gt;&apos;)def gello_stu_id(id): return &apos;Hello World id: %s&apos; % id e) 启动服务： 12if __name__ == &apos;__main__&apos;: app.run() 注意：__name__ == &#39;__main__&#39;在此处使用是用于确保web服务已经启动当脚本被立即执行。当脚本被另一个脚本导入，它被看做父脚本将启动不同的服务，所以app.run()调用会被跳过。 一旦服务启动，它将进入循环等待请求并为之服务。这个循环持续到应用程序停止，例如通过按下Ctrl+C。 有几个选项参数可以给app.run()配置web服务的操作模式。在开发期间，可以很方便的开启debug模式，将激活 debugger 和 reloader 。这样做是通过传递debug为True来实现的。 run()中参数有如下： 123debug 是否开启调试模式，开启后修改python的代码会自动重启port 启动指定服务器的端口号host主机，默认是127.0.0.1 修改启动方式，使用命令行参数启动服务安装插件1pip install flask-script 调整代码 manager = Manager(app=‘自定义的flask对象’) 启动的地方 manager.run() 启动命令1python hellow.py runserver -h 地址 -p 端口 -d -r 其中：-h表示地址。-p表示端口。-d表示debug模式。-r表示自动重启 route规则写法：converter:variable_name converter类型： 123456string 字符串int 整形float 浮点型path 接受路径，接收的时候是str，/也当做字符串的一个字符uuid 只接受uuid字符串any 可以同时指定多种路径，进行限定 例子： 123456789@app.route(&apos;/helloint/&lt;int:id&gt;/&apos;)@app.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)@app.route(&apos;/getstr/&lt;string:name&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;])@app.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)@app.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;，methods=[&apos;GET&apos;, &apos;POST&apos;]) 实现对应的视图函数： 1234567891011121314151617181920212223242526272829303132333435@blue.route(&apos;/hello/&lt;name&gt;/&apos;)def hello_man(name): print(type(name)) return &apos;hello name:%s type:%s&apos; % (name, type(name))@blue.route(&apos;/helloint/&lt;int:id&gt;/&apos;)def hello_int(id): print(id) print(type(id)) return &apos;hello int: %s&apos; % (id)@blue.route(&apos;/index/&apos;)def index(): return render_template(&apos;hello.html&apos;)@blue.route(&apos;/getfloat/&lt;float:price&gt;/&apos;)def hello_float(price): return &apos;float: %s&apos; % price@blue.route(&apos;/getstr/&lt;string:name&gt;/&apos;)def hello_name(name): return &apos;hello name: %s&apos; % name@blue.route(&apos;/getpath/&lt;path:url_path&gt;/&apos;)def hello_path(url_path): return &apos;path: %s&apos; % url_path@blue.route(&apos;/getuuid/&apos;)def gello_get_uuid(): a = uuid.uuid4() return str(a)@blue.route(&apos;/getbyuuid/&lt;uuid:uu&gt;/&apos;)def hello_uuid(uu): return &apos;uu:%s&apos; % uu methods请求方法常用的请求类型有如下几种 12345GET : 获取POST : 创建PUT : 修改(全部属性都修改)DELETE : 删除PATCH : 修改(修改部分属性) 定义url的请求类型: 1@blue.route(&apos;/getrequest/&apos;, methods=[&apos;GET&apos;, &apos;POST&apos;])","categories":[{"name":"Flask","slug":"Flask","permalink":"http://alexyanglong.github.io/categories/Flask/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"http://alexyanglong.github.io/tags/Flask/"}]},{"title":"Django -- 在CentOS 7上部署Django项目","slug":"Django----在CentOS-7上部署Django项目","date":"2018-05-30T16:00:00.000Z","updated":"2018-06-25T07:36:15.796Z","comments":true,"path":"2018/05/31/Django----在CentOS-7上部署Django项目/","link":"","permalink":"http://alexyanglong.github.io/2018/05/31/Django----在CentOS-7上部署Django项目/","excerpt":"","text":"Django – 在CentOS 7上部署Django项目在部署之前，要确保CentOS 7系统已经安装了MySQL 5.x数据库、Python 3.6.x和Nginx。 部署准备在CentOS 7的根目录 / 下创建一个project 目录，该目录用于存放所有要部署的项目。在project 下在创建conf （用户存放所有的配置文件）、 env （用户存放所有的虚拟环境）、 src （用于存放所有项目的源码）、 logs（用于存放所有的日志文件）。 同步数据使用navicat 将Windows上的数据库同步到CentOS上。首先要确保CentOS上的MySQL可以支持远程连接。 安装虚拟环境12345678910# 切换目录cd /project/env# 安装虚拟环境 参数：指定虚拟环境中Python的版本（-p 本地Python3的安装目录）virtualenv --no-site-packages -p /usr/local/python3.6 axfvenv# 进入虚拟环境目录cd venv# 激活虚拟环境source bin/activate# 安装环境所需要的包 其中re_install.txt文件中记录的是需要安装包的名称以及对应的版本pip3 install -r re_install.txt Django的项目中，在工程目录下settings.py文件中有一个DEBUG=True参数，如果DEBUG=False则会出现js，css，img无法加载的情况出现。 原因如下： Django框架仅在开发模式下提供静态文件服务。当开启DEBUG模式时，Django内置的服务器是提供静态文件的服务的，所以css等文件访问都没有问题，但是关闭DEBUG模式后，Django便不提供静态文件服务了。 部署在测试环境中在测试环境中一般都直接使用python manage.py runserver的方式去运行项目。其中就涉及到DEBUG=False的修改，静态目录的修改等，具体修改如下： 1修改settings.py配置文件中的DEBUG=False模式，修改ALLOEWD_HOST=[&apos;*&apos;] 修改项目目录下的urls.py 123456789# 引入包from django.views.static import serveurlpatterns = [ ..., # 增加以下的url路由 url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, &#123;&quot;document_root&quot;: settings.STATICFILES_DIRS[0]&#125;),] 使用python manage.py runserver 运行项目。 部署在正式环境中使用 uwsgi + Nginx + MySQL 来部署项目。 配置nginx.conf文件1cd /project/conf 先编写自己项目的nginx.conf文件如下： 每一个项目对应有一个自己定义的nginx的配置文件，比如爱鲜蜂项目，定义为axf_nginx.conf 文件。 1234567891011121314151617server &#123; listen 80; # 端口 server_name xx.xx.xx.xx localhost; # 公网ip、域名 access_log /project/logs/axf_access.log; # 连接成功日志文件 error_log /project/logs/axf_error.log; # 错误日志 location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8090; # 和uwsgi通信的端口 &#125; location /static/ &#123; alias /project/src/axf/static/; # 静态文件 expires 30d; &#125; &#125; 再修改总的nginx的配置文件，让总的nginx文件包含我们自定义的项目的axf_nginx.conf 文件。 总的nginx配置文件在：/etc/nginx/nginx.conf 中 django_centos_nginx1 以上步骤操作完成以后，需要重启nginx： 123systemctl restart nginxsystemctl status nginx 如果自定义的axf_nginx.conf文件没有错误的话，查看nginx的运行状态会有如下的结果： django_centos_nginx2 配置uwsgi文件先安装uwsgi 1pip3 install uwsgi 然后进行环境变量的配置， 建立软连接 1ln -s /usr/local/python3.6/bin/uwsgi /usr/bin/uwsgi 在 /project/conf 文件夹下除了包含自定义的axf_nginx.conf文件，还有我们自定义的axf_uwsgi.ini 配置文件。 123456789101112131415161718192021222324252627[uwsgi]projectname = axfbase = /project/src# 守护进程master = true# 进程个数processes = 4# 虚拟环境pythonhome = /project/env/axfvenv# 项目地址chdir = %(base)/%(projectname)# 指定python版本pythonpath = /usr/local/python3/bin/python3# 指定uwsgi文件module = %(projectname).wsgi# 和nginx通信地址:端口socket = 127.0.0.1:8090# 日志文件地址logto = /project/logs/axf_uwsgi.log 运行项目: 123cd /project/confuwsgi --ini uwsgi.ini","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- 分页、中间件、验证码、文件上传","slug":"Django -- 分页、中间件、验证码、文件上传","date":"2018-05-28T16:00:00.000Z","updated":"2018-06-25T08:21:01.499Z","comments":true,"path":"2018/05/29/Django -- 分页、中间件、验证码、文件上传/","link":"","permalink":"http://alexyanglong.github.io/2018/05/29/Django -- 分页、中间件、验证码、文件上传/","excerpt":"","text":"Django – 分页、中间件、验证码、文件上传中间件Middleware中间件： a) 是一个轻量级的，底层的插件，可以介入Django的请求和响应的过程（面向切面编程) b) 中间件的本质就是一个python类 c) 面向切面编程(Aspect Oriented Programming)简称AOP，AOP的主要实现目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获取逻辑过程中各部分之间低耦合的隔离效果 中间件的处理函数1234567891011__init__：没有参数，在服务器响应的第一个请求的时候自动调用，用户确定时候启动该中间件process_request(self, request): 在执行视图前被调用，每个请求上都会被调用，不主动进行返回或返回HttpResponse对象process_view(self, request, view_func,view_args, view_kwargs):调用视图之前执行，每个请求都会调用，不主动进行返回或返回HttpResponse对象process_template_response(self, request, response)：在视图刚好执行完后进行调用，每个请求都会调用，不主动进行返回或返回HttpResponse对象process_response(self, request, response):所有响应返回浏览器之前调用，每个请求都会调用，不主动进行返回或返回HttpResponse对象process_exception(self, request, exception):当视图抛出异常时调用，不主动进行返回或返回HttpResponse对象 处理流程 django_middleware1 自定义中间件 在工程目录下创建middleware目录 目录中创建一个python文件 在根据功能需求，创建切入需求类，重写切入点方法 编写代码： 12345from django.utils.deprecation import MiddlewareMixin class AuthUserMiddleWare(MiddlewareMixin): def process_request(self, request): print(‘xxxx’) 启动中间件，在settings中进行配置，MIDDLEWARE中添加middleware.文件名.类名 分页分页库Paginator的基本语法django提供了分页的工具，存在于django.core中 12Paginator： 数据分页工具Page：具体的某一页 Paginator： 1对象创建： Paginator(数据集，每一页数据的条数) 属性： 123count 计算和num_pages: 页面总和page_range: 页码列表，从1开始 方法： 1page(页码)：获取的一个page对象，页码不存在则抛出invalidPage的异常 常见错误：123invalidPage：page()传递无效页码PageNotAnInteger：Page()传递的不是整数Empty:page()传递的值有效，但是没有数据 page对象page： 1对象获取，通过Paginator的page()方法获得 属性： 123object_list: 当前页面上所有的数据对象number： 当前页的页码值paginator: 当前page关联的Paginator对象 方法：123456has_next() 判断是否有下一页has_previous(): 判断是否有上一页has_other_pages(): 判断是否有上一页或下一页next_page_number(); 返回下一页的页码previous_page_number(): 返回上一页的页码len(): 返回当前也的数据的个数 Paginator对象和Page对象的关系如下有学生表，学生表中有25条数据，通过分页，每一个6条数据，去实现分页的功能: django_paginator1 代码： django_paginator1 验证码在用户登录，注册以及一些敏感操作的时候，我们为了防止服务器被暴力请求，或爬虫爬取，我们可以使用验证码进行过滤，减轻服务器的压力。 验证码需要使用绘图Pillow 1Pip install Pillow 核心： 1image.ImageDraw.ImageFont 绘制流程： 12345678910111213141516171819background = (10,20,30) RGB颜色初始化画布 image = Image.new(‘RGB’,(100,50), background)获取画布中画笔对象draw = ImageDraw.Draw(image, ‘RGB’)绘制验证码，随机四个导入字体文件path表示路径font = ImageFont.truetype(‘path’, size)fontcolor = (20,40,60)draw.text((x,y), ‘R’, font.fontcolor) x,y是文字左上角坐标 文件上传以上传图片为例，同样也需要安装Pillow库。 在Model中定义保存图片的字段1234567class Student(models.Model): name = models.CharField(max_length=20, null=False) gender = models.BooleanField(default=True) age = models.IntegerField() avatar = models.ImageField(upload_to='upload') # 头像 create_time = models.DateTimeField(auto_now_add=True) update_time = models.DateTimeField(auto_now=True) 注意：在指定字段为ImageField类型的时候，要指定upload_to参数，表示上传的图片的保存路径。 配置上传图片的保存路径先在根目录下创建media目录。 在工程目录下的settings.py中配置media_url和media_root路径。 12MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, '/media/') 在工程目录下的urls.py文件中配置media的目录为静态目录。 123456789101112131415from django.conf.urls import urlfrom django.contrib import admin# 导入static包from django.contrib.staticfiles.urls import static# 导入settingsfrom test_p import settingsurlpatterns = [ url(r'^admin/', admin.site.urls), ...,]# 设置mediaurlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) 实现保存图片 django_paginator1 注意：上传的时候，需要指定form表单的enctype=‘multipart/form-data’ 页面中解析上传的图片信息在数据库中用于保存图片的字段s_content的字段中存的是media下的upload/xxx.jpg地址，所以在页面解析的时候，需要加上media的目录，这样才能解析到图片在服务器中的路径。 django_paginator1","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- 视图","slug":"Django----视图","date":"2018-05-27T16:00:00.000Z","updated":"2018-06-25T09:08:56.768Z","comments":true,"path":"2018/05/28/Django----视图/","link":"","permalink":"http://alexyanglong.github.io/2018/05/28/Django----视图/","excerpt":"","text":"Django – 视图MVT模式中的V，V代表视图，在Django中的视图主要用来接受web请求，并做出响应。视图的本质就是一个python中的函数 视图的响应分为：以json数据形式返回、以网页的形式返回、重定向到另一个网页、错误视图页面（404,500等）。视图响应的过程：浏览器输入 → django获取信息并去掉ip：端口，身下路径 → urls路由匹配 → 视图响应 → 回馈到浏览器。 url配置配置流程1settings中制定根级url配置文件，对应的属性ROOT_URLCONF urlpatterns123一个url实例的对象，全在根配置搞定 内部由url组成（正则匹配路径） url(r&apos;^learn/&apos;, views.learn) 导入其他的url配置123456789在应用中创建urls.py 文件，编写配置规则，在工程urls.py中进行导入包含 From django.conf.urls import include urlpatterns = [url(r&apos;^xxx/&apos;, include(&apos;app.urls&apos;))]注意： url配置正则注意事项： 正则匹配时从上到下进行遍历，匹配到就不会继续向后查找了 匹配的正则前方不需要加反斜杠 正则钱需要加（r）表示字符串不转义 获取url路径的参数url传递一个参数123果需要从url中获取一个值，需要对正则加小括号url(r&apos;^grade/(\\d+)$&apos;, views.getStudent)注意，url匹配中添加了()取参，在请求调用的函数中必须接收 eg: def getStudent(request, classid) django_views1 url传递多个参数1234如果需要获取url路径中的多个参数，那就添加多个括号，默认按照顺序匹配路径名字，参数顺序必须固定定义url中传递三个参数的地址： url(r&apos;^news/(\\d&#123;4&#125;)/(\\d)+/(\\d+)$&apos;, views.getNews) 实现方法：匹配年月日 def getNews(requests, year, month, day) 例子：查找计算机技术书籍下的脚本语言中的python的书籍信息 使用关键词获取参数参数也可以使用关键字参数形式,参数顺序可以任意 url(r&#39;news/(?P\\d{4})/(?P\\d+)/(?P\\d+)$&#39;, views.getNews) django_views3 反向解析在模板中进行反解析使用关键字参数 1&#123;% &apos;url&apos; &apos;namespace:name&apos; key=value key1=value1 %&#125; 定义url在根urls中 1url(r&apos;^apps/&apos;, include(&apos;App.urls&apos;, namespace=&apos;app&apos;)) 在子urls中 1url(r&apos;^hello/(\\d+)&apos;, views.hello, name=&apos;sayhello&apos;) 在模板中使用: 1&lt;a href=&apos;&#123;% url &apos;app:sayhello&apos; grade_id%&#125;&apos;&gt; 其中grade_id是参数，其中参数可以使用位置参数，也可以使用关键词参数，和配置urls一样 django_views4 在views中使用反向解析使用反向解析优点 如果在视图中，模板中使用硬编码连接，在url配置发生改变时，需要变更的代码会非常多，这样导致我们的代码结构不是很容易维护，使用反向解析可以提高我们代码的扩展性和可维护性 12HttpResponseRedirect(reverse(namespace:name, kwargs = &#123;key1 : value1, key2 : value2&#125;))# kwargs 是字典 django_views5 视图错误视图位置：通常在应用下的views.py中定义 错误视图： 404视图（页面没有被找到 page not found） 400视图（客户端操作错误 bad request） 403视图（权限错误 403 forbidden ） 500视图（服务器内部错误 server error） 自定义错误视图####修改debug模式 在工程的settings中修改debug模式： 注意： 需要在debug=False的情况下才可以 没有关闭debug的情况下会在界面中直接显示错误的信息 在templates文件中定义自己的错误样式 django_views7 请求与响应HttpRequest定义12345678910111213服务器在接收到http请求后，会根据报文创建HttpRequest对象视图中第一个参数就是HttpRequest对象Django框架会进行自己的包装，之后传递给视图属性： path 请求的完整路径 method 请求的方法，通常get，post Encoding 编码方式，常用utf-8 Get 类似字典的参数，包含了get的所有参数 post 类似字典的参数，包含了post的所有参数 Files 类似字典的参数，包含了上传的文件 Cookies 字典，包含了所有的COOKIES Session 类似字典，表示会话 方法： is_ajax() 判断是否是ajax()，通常在移动端和js中 响应QueryDict类型1234561）类似字典的结构数据，与字典的区别，可以存在相同的键2）GET和POST都是QueryDict对象3）QueryDict中数据获取方式 dict[&apos;name&apos;] 或者dict.get(&apos;name&apos;) 获取指定key对应的所有值 dict.getlist(&apos;name&apos;) django_views8 如下，获取重复提交数据的方法： 响应123456789101112131415161718192021222324252627282930311）可以直接返回一个HttpResponse对象： 服务器返回给客户端的数据，HttpResponse由程序员自己创建 不使用模板，直接HttpResponse()2）可以返回模板调用模板，进行渲染，直接使用render一步到位返回表达式： render(request, template_name, context) request 请求体对象 template_name 模板路径 context 字典参数，用来填坑3）属性 Content 返回的内容 Charset 编码格式 status_code 响应状态码（200,4xx,5xx） 4xx 客户端的错误 5xx 服务端的错误 content_type MIME类型，定义传输类型的，比如有xml，html，png等等，比如content_type=&apos;image/jpg&apos;4）方法 init 初始化内容 write(xxx) 直接写到文本 flush 冲刷缓冲区 set_cookie(key, value=&apos;&apos;, max_age=None, exprise=None) delete_cookie(key) 删除cookie，上面是设置4）重定向 HttpResponseRedirect响应重定向：可以实现服务器内部的跳转 Return HttpResponseRedirect(&apos;/xxx/xxx&apos;) 使用的时候推荐使用反向解析 JsonResponse 使用json数据的请求，通常用在异步请求上jsonResponse(dict) content_type是application/json","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- 模型","slug":"Django----模型","date":"2018-05-26T16:00:00.000Z","updated":"2018-06-25T08:39:38.262Z","comments":true,"path":"2018/05/27/Django----模型/","link":"","permalink":"http://alexyanglong.github.io/2018/05/27/Django----模型/","excerpt":"","text":"Django – 模型Django对数据库提供了很好的支持，对不同的数据库，django提供了统一调用的API，我们可以根据不同的业务需求使用不同是数据库。Django中引入了ORM(Objects Relational Mapping)对象关系映射，是一种程序技术，可以简化我们对数据库的操作。 定义模型重要概念：模型，表，属性，字段 一个模型类在数据库中对应一张表，在模型类中定义的属性，对应模型对照表中的一个字段。 准备在应用文件目录下的models.py 中创建Student 、Grade 两个Model。 123456789101112131415class Grade(models.Model): name = models.CharField(max_length=10, null=False) create_time = models.DateTimeField(auto_now_add=True) update_time = models.DateTimeField(auto_now_add=True, auto_now=True)class Student(models.Model): name = models.CharField(max_length=20, null=False) gender = models.BooleanField(default=True) age = models.IntegerField() create_time = models.DateTimeField(auto_now_add=True) update_time = models.DateTimeField(auto_now_add=True, auto_now=True) grade = models.ForeignKey(Grade) 然后生成迁移文件、执行迁移文件。 注意：如果执行python manage.py makemigrations后并没有生成迁移文件，一直提示No changes detected这个结果的话，就要手动的去处理了。有两点处理方式： 1） 先删除掉__pycache__文件夹 2） 直接强制的去执行迁移命令，python manage.py makemigrations xxx (xxx就是app的名称) 3） 查看自动生成的数据库，查看表django_migrations，删掉app字段为xxx的数据(xxx就是app的名称) ORMORM(Objects Relational Mapping)对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。可以简单理解为翻译机。 django_models_orm 模型查询a) 模型成员objects Django默认通过模型的objects对象实现模型数据查询 b) 过滤器 查询集表示从数据库获取的对象集合 查询集可以有多个过滤器 过滤器就是一个函数，基于所给的参数限制查询的结果 1234567从SQL角度来说，查询集合和select语句等价，过滤器就像where条件Django有两种过滤器用于筛选记录 filter : 返回符合筛选条件的数据集 exclude : 返回不符合筛选条件的数据集 多个filter和exclude可以连接在一起查询 当然还有如下这些过滤器: 123456789all() 返回所有数据filter() 返回符合条件的数据exclude() 过滤掉符合条件的数据order_by() 排序values() 一条数据就是一个字典，返回一个列表 c) 查询单个数据 get()：返回一个满足条件的对象。如果没有返回符合条件的对象，会应该模型类DoesNotExist异常，如果找到多个，会引发模型类MultiObjectsReturned异常 first()：返回查询集中的第一个对象 last()：返回查询集中的最后一个对象 count()：返回当前查询集中的对象个数 exists()：判断查询集中是否有数据，如果有数据返回True，没有返回False d) 限制查询集 限制查询集，可以使用下表的方法进行限制，等同于sql中的limit 模型名.objects.all()[0:5] 小标不能为负数 e) 字段查询 对sql中的where实现，作为方法，filter(),exclude()，get()的参数 语法：属性名称__比较运算符 = 值 外键：属性名_id 注意：like语句中使用%表示通配符。比如sql语句查询 where name like ‘%xxx%’，等同于filter(name_contains=’xxx’) f) 比较运算符 contains：是否包含，大小写敏感 startswith，endswith：以values开头或者结尾，大小写敏感 以上的运算符前加上i(ignore)就不区分大小写了 isnull，isnotnull：是否为空。filter(name__isnull=True) in：是否包含在范围内。filter(id__in=[1,2,3]) gt，gte，lt，lte：大于，大于等于，小于，小于等于。filter(age__gt=10) pk：代表主键，也就是id。filter(pk=1) g) 聚合函数 agregate()函数返回聚合函数的值 Avg：平均值 Count：数量 Max：最大 Min：最小 Sum：求和 例如: Student.objects.aggregate(Max(‘age’)) h) F对象/Q对象 F对象:可以使用模型的A属性与B属性进行比较 背景:在模型中有两个字段，分别表示学生成绩A与成绩B，要对成绩AB进行比较计算，就需要使用到F对象。 例如有如下例子1: 123# 班级中有女生个数字段以及男生个数字段，统计女生数大于男生数的班级grades = Grade.objects.filter(girlnum__gt=F('boynum')) F对象支持算数运算 1grades = Grade.objects.filter(girlnum__gt=F('boynum') + 10) 例子2： 123456# 查询python班下语文成绩超过数学成绩10分的学生grade = Grade.objects.filter(g_name='python').first()students = grade.student_set.all() stu = students.filter(s_yuwen__gt= F('s_shuxue') + 10) Q对象: Q()对象就是为了将过滤条件组合起来 当我们在查询的条件中需要组合条件时(例如两个条件“且”或者“或”)时。我们可以使用Q()查询对象 使用符号&amp;或者|将多个Q()对象组合起来传递给filter()，exclude()，get()等函数 Q()对象的前面使用字符“~”来代表意义“非” 例子1: 查询学生中不是12岁的或者姓名叫张三的学生 1student = Student.objects.filter(~Q(age=12) | Q(name='张三')) 例子2： 查询python班语文小于80并且数学小于等于80的学生 123grade = Grade.objects.filter(g_name='python').first()students = grade.student_set.all()stu = students.filter(~Q(s_yuwen__gte=80) &amp; Q(s_shuxue__lte=80)) 例子3： 查询python班语文大于等于80或者数学小于等于80的学生 1234grade = Grade.objects.filter(g_name='python').first()students = grade.student_set.all()stu = students.filter(Q(s_yuwen__gte=80) | Q(s_shuxue__lte=80)) 模型字段定义属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105概述 ·django根据属性的类型确定以下信息 ·当前选择的数据库支持字段的类型 ·渲染管理表单时使用的默认html控件 ·在管理站点最低限度的验证 ·django会为表增加自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后，则django不会再生成默认的主键列 ·属性命名限制 ·遵循标识符规则(不使用python预定义的标识符号，内置函数名，异常等。避免使用下划线等) ·由于django的查询方式，不允许使用连续的下划线库 ·定义属性时，需要字段类型，字段类型被定义在django.db.models.fields目录下，为了方便使用，被导入到django.db.models中 ·使用方式 ·导入from django.db import models ·通过models.Field创建字段类型的对象，赋值给属性逻辑删除 ·对于重要数据都做逻辑删除，不做物理删除，实现方法是定义isDelete属性，类型为BooleanField，默认值为False字段类型 ·AutoField ·一个根据实际ID自动增长的IntegerField，通常不指定如果不指定，一个主键字段将自动添加到模型中 ·CharField(max_length=字符长度) ·字符串，默认的表单样式是 TextInput ·TextField ·大文本字段，一般超过4000使用，默认的表单控件是Textarea ·IntegerField ·整数 ·DecimalField(max_digits=None, decimal_places=None) ·使用python的Decimal实例表示的十进制浮点数 ·参数说明 ·DecimalField.max_digits ·位数总数 ·DecimalField.decimal_places ·小数点后的数字位数 ·FloatField ·用Python的float实例来表示的浮点数 ·BooleanField ·true/false 字段，此字段的默认表单控制是CheckboxInput ·NullBooleanField ·支持null、true、false三种值 ·DateField([auto_now=False, auto_now_add=False]) ·使用Python的datetime.date实例表示的日期 ·参数说明 ·DateField.auto_now ·每次保存对象时，自动设置该字段为当前时间，用于&quot;最后一次修改&quot;的时间戳，它总是使用当前日期，默认为false ·DateField.auto_now_add ·当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为false ·说明 ·该字段默认对应的表单控件是一个TextInput. 在管理员站点添加了一个JavaScript写的日历控件，和一个“Today&quot;的快捷按钮，包含了一个额外的invalid_date错误消息键 ·注意 ·auto_now_add, auto_now, and default 这些设置是相互排斥的，他们之间的任何组合将会发生错误的结果 ·TimeField ·使用Python的datetime.time实例表示的时间，参数同DateField ·DateTimeField ·使用Python的datetime.datetime实例表示的日期和时间，参数同DateField ·FileField ·一个上传文件的字段 ·ImageField ·继承了FileField的所有属性和方法，但对上传的对象进行校验，确保它是个有效的image字段选项 ·概述 ·通过字段选项，可以实现对字段的约束 ·在字段对象时通过关键字参数指定 ·null ·如果为True，则该字段在数据库中是空数据，默认值是 False ·blank ·如果为True，则该字段允许为空白，默认值是 False ·注意 ·null是数据库范畴的概念，blank是表单验证证范畴的 ·db_column ·字段的名称，如果未指定，则使用属性的名称 ·db_index ·若值为 True, 则在表中会为此字段创建索引 ·default ·默认值 ·primary_key ·若为 True, 则该字段会成为模型的主键字段 ·unique ·如果为 True, 这个字段在表中必须有唯一值 模型间的关联关系一对一模型1234567891011121314151617181920212223# 创建学生的模型：class Student(models.Model): stu_name = models.CharField(max_length=6, unique=True) stu_sex = models.BooleanField(default=0) stu_birth = models.DateField() stu_delete = models.BooleanField(default=0) stu_create_time = models.DateField(auto_now_add=True) stu_operate_time = models.DateField(auto_now=True) stu_tel = models.CharField(max_length=11) stu_yuwen = models.DecimalField(max_digits=3, decimal_places=1, default=0) stu_shuxue = models.DecimalField(max_digits=3, decimal_places=1, default=0) class Meta: db_table = 'stu'# 创建学生拓展的模型：class StuInfo(models.Model): stu_addr = models.CharField(max_length=30) stu_age = models.IntegerField() stu = models.OneToOneField(Student) class Meta: db_table = 'stu_info' 1234使用models.OneToOneField()进行关联class StuInfo(models.Model):下是通过班级获取学生信 stu = models.OneToOneField(Student)注意：在数据中关联字段名称叫stu_id 通过学生拓展表去获取学生信息12345stuinfo = StuInfo.objects.all().first()student = stuinfo.stu注意：通过拓展表去获取学生的信息的话，语法如下； 学生拓展表的单条对象.关联字段，即可获取到学生表的数据 通过学生获取扩展信息112345stu = Student.objects.all().first()stuInfo = stu.stuInfo注意：通过学生获取关联表的数据的话，语法如下： 学生对象.关联的表名，即可获取到关联表的数据 通过学生获取扩展信息21234567在关联字段OneToOneField中加入参数related_name=&apos;xxx&apos;stu = Student.objects.all().first()stuInfo = stu.xxx注意：通过学生获取关联表的数据的话，语法如下： 学生对象.关联的字段中定义的related_name参数，即可获取到关联表的数据 设置对应关系的字段为保护模式12345678910111213models.CASCADE 默认值models.PROTECT 保护模式models.SET_NULL 置空模式models.SET_DETAULT 置默认值models.SET() 删除的时候吃重新动态指向一个实体访问对象元素on_delete = models.PROTECT修改on_delete参数models.OneToOneField(&apos;Student&apos;, on_delete=models.SET_NULL, null=True)在删除student对象的时候，stuinfo的关联字段会设置为空null=True，如下命令去删除student的数据：Student.objects.filter(id=1).delete() 定义on_delete=models.PROTECT1234p = Student.objects.all().first()p.delete()注意：这个时候去执行该业务逻辑的方法的时候会报错 一对多模型12345678910# 定义一个班级类还有学生类，实现一对多的关系：# 先定义班级类Class Grade(models.Model): g_name = models.CharField(max_length=16)# 定义studentclass Student: s_name = models.CharField(max_length=10) s_age = models.IntegerField(default=1) s_grade = models.ForeignKey(Grade, on_delete=PROTECT) 注意：使用models.ForeignKey关联 获取对象元素 grade.student_set 获取数据语法：通过一获取多的数据 公式： 一的对象.多的模型_set 然后在获取数据all(), get(), filter() 等等 如下先通过学生去获取班级信息： 12stu = Student.objects.first()stu.stu_grade 如下是通过班级获取学生信息： 12g = Grade.objects.all().first()g.stugrade.all() ---&gt; 其中stugrade是定义的related_name参数 重点： 定义了related_name字段以后，只能通过related_name去反向获取数据，在也不能通过_set方法去获取数据了 性能对比12345678获取班级的学生(通过一获取多)1. 低性能方法：g = Grade.objects.all().first()s = Student.objects.filter(s_grade=g)2. 高性能方法：g = Grate.objects.all().first()s = g.student_set.all() 练习题获取python班下的所有学生的信息12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.all() 获取python班下语文成绩大于80分的女学生12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_yuwen__gte=80) 获取python班下语文成绩超过数学成绩10分的男学生12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_yuwen__gte=F(&apos;stu_shuxue&apos;) + 10) 获取出生在80后的男学生，查看他们的班级12gs = Grade.objects.filter(g_name=&apos;python&apos;)[0]allstu = gs.student_set.filter(stu_birth__gte=&apos;1980-01-01&apos;, stu_birth__lte=&apos;1990-01-01&apos;) 多对多M:N 模型定义购物车，用户的例子实现多对多： 123456789# 1. 创建用户模型: class GoodsUser(models.Model): u_name = models.CharField(max_length=32) # 2. 创建商品模型:class Goods(models.Model): g_name = models.CharField(max_length=32) g_user = models.ManyToManyField(User) 对多表结构123456多对多关系：1. 生成表的时候会多生成一张表（实际会有三张表）2. 生成的表是专门用来维护关系的3. 生成的表是使用两个外键来维护多对多的关系4. 两个一对多的关系来实现多对多的实现 5. 删除一个表的数据的话，中间关联表也要删除相关的信息 练习题获取第一个用户购买了那些商品12gu = GoodsUser.objects.all().first()allstu = gu.goods_set.all() 获取指定商品的购买用户信息12g = Goods.objects.filter(id=1)[0]g.g_user.all()","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- Admin管理模块的使用","slug":"Django----Admin管理模块的使用","date":"2018-05-24T16:00:00.000Z","updated":"2018-06-25T08:22:06.116Z","comments":true,"path":"2018/05/25/Django----Admin管理模块的使用/","link":"","permalink":"http://alexyanglong.github.io/2018/05/25/Django----Admin管理模块的使用/","excerpt":"","text":"Django – Admin管理模块的使用Djang自身集成了管理后台，在管理后台中可以对我们自定义model进行CRUD操作，也能进行列表展示解析，分页等等。 准备先创建一个项目test_p，在项目中创建应用testapp，将项目配置这些配置好。 创建一个model在应用文件目录下的models.py 中创建Student 、Grade 两个Model。 1234567891011121314151617181920from django.db import models# Create your models here.class Grade(models.Model): name = models.CharField(max_length=10, null=False) create_time = models.DateTimeField(auto_now_add=True) update_time = models.DateTimeField(auto_now_add=True, auto_now=True)class Student(models.Model): name = models.CharField(max_length=20, null=False) gender = models.BooleanField(default=True) age = models.IntegerField() create_time = models.DateTimeField(auto_now_add=True) update_time = models.DateTimeField(auto_now_add=True, auto_now=True) grade = models.ForeignKey(Grade) admin管理后台的url在项目文件目录下可以看到路由配置文件urls.py中有一个admin的url地址 123456from django.conf.urls import urlfrom django.contrib import adminurlpatterns = [ url(r'^admin/', admin.site.urls),] 创建admin后台的用户密码在创建用户之前，先要在终端中使用命令迁移数据库。点击IDE最下方的Terminal，进入终端，先检查虚拟环境是否正确，若不正确，先配置虚拟环境。 在终端中输入命令： python manage.py makemigrations 生成迁移文件 python manage.py migrate 执行迁移文件 数据库迁移成功后，开始创建用户，命令如下： python manage.py createsuperuser 创建超级用户 接着要填写用户名、邮箱、密码、确认密码。如图： Admin——创建用户 创建用户名成功之后，在浏览器中输入 127.0.0.1:8000/admin/ 或 localhost:8000/admin/ 进行登录。 在管理后台中管理模型对象需要在应用文件目录下的admin.py 文件中注册要进行管理的Model。 1234# admin.site.register(模型名)admin.site.register(Grade)admin.site.register(Student) 当然也可以继承admin.ModelAdmin，编写自己的admin，来自定义Model的后台管理展示界面。 123456789101112131415class StudentAdmin(admin.ModelAdmin): def set_gender(self): if self.gender: return '男' else: return '女' set_gender.short_description = '性别' list_display = ['id', 'name', set_gender] list_filter = ['gender'] search_fields = ['name'] list_per_page = 10 admin.site.register(Student, StudentAdmin) 说明： short_description ：表示此字段在界面显示的名称 list_display ：表示需要显示的字段 list_filter ：表示可以进行过滤的字段 search_fields ：表示可以进行搜索的字段 list_per_page ：表示分页的条数 ordering ：表示排序的字段 界面显示如下： Admin——Model管理界面 此外，还可以使用装饰器来实现自定义Model的后台管理展示界面。 1234567891011121314# @admin.register(模型名)@admin.register(Student)class StudentAdmin(admin.ModelAdmin): def set_gender(self): if self.gender: return '男' else: return '女' set_gender.short_description = '性别' list_display = ['id', 'name', set_gender] list_filter = ['gender'] search_fields = ['name'] list_per_page = 10","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- 创建应用、修改配置","slug":"Django -- 创建应用、修改配置","date":"2018-05-22T16:00:00.000Z","updated":"2018-06-25T07:36:22.813Z","comments":true,"path":"2018/05/23/Django -- 创建应用、修改配置/","link":"","permalink":"http://alexyanglong.github.io/2018/05/23/Django -- 创建应用、修改配置/","excerpt":"","text":"Django – 创建应用、修改配置在黑屏终端中创建应用在创建应用APP之前，先创建一个Django的项目。 开启黑屏终端，进入项目所在目录，执行创建APP命令（注意要在虚拟环境中执行）： 12cd &lt;project directory&gt;python manage.py startapp app-name 这样，一个应用就创建成功。但是这个应用APP还不能应用于项目，需要在Django项目目录中进行配置（稍后再说）。 使用PyCharm创建项目与应用创建项目打开PyCharm软件，点击“Create New Project” 创建项目1 选择左侧“Django”选项，在右侧选择项目存放路径以及给项目命名，之后选择项目的解释器环境，这里推荐使用自己创建的虚拟环境，不要使用本地环境或者默认创建的虚拟环境。最后是让Django自动创建templates模板目录，当然这里也可以直接创建应用APP。也可以稍后通过命令创建。接下来点击“Create”按钮，开始创建项目。 创建项目2 等待项目创建成功，项目在创建时，会下载一些第三方库，比如django框架的库，所以会花费一些时间。耐心等待…… 出现下面界面，项目创建成功。 创建项目3 项目文件说明： manage.py 是Django用于管理本项目的管理集工具，之后站点运行，数据库自动生成，数据表的修改等都是通过运行该文件完成。 __init__.py 指明该目录结构是一个python包，暂无内容，在后期会初始化一些工具会使用到。 seetings.py Django项目的配置文件，其中定义了本项目的引用组件，项目名，数据库，静态资源，调试模式，域名限制等。 urls.py 项目的URL路由映射，实现客户端请求url由哪个模块进行响应。 wsgi.py 定义WSGI接口信息，通常本文件生成后无需改动 创建应用项目创建好以后，就可以创建应用了（如果之前在选项中填写了应用，就会由Django自动创建应用）。在PyCharm界面的最下方，点击“Terminal”选项，进入终端，注意查看虚拟环境是否是正确的。之后在命令行中输入python manage.py startapp app-name 就创建了一个应用。 创建应用1 创建应用2 激活应用刚创建的应用，需要在项目配置文件中进行配置才能使用。首先需要在项目目录中的“settings.py”文件中的INSTALLED_APPS 中添加应用的名字。 配置1 配置语言与时区还是在项目目录中的“settings.py”文件中进行配置。 配置2 配置数据库在“settings.py”文件中找到 DATABASES 改为： 配置4 其中 ENGINE 表示数据库引擎，即使用哪种数据库，这里使用mysql数据库，NAME 表示数据库名，USER 表示用登录mysql的用户名，PASSWORD 表示登录的密码，HOST 表示服务器主机的地址，PORT 表示端口。 注意：如果要使用mysql，需要在虚拟环境中安装第三方库pip install PyMySQL ，同时需要在项目文件目录（不是应用文件目录）中的__init__.py 文件中做如下修改，完成数据库的驱动加载： 123import pymysqlpymysql.install_as_MySQLdb() 配置模板目录这里的模板就是HTML页面。在“settings.py”文件中找到 TEMPLATES ，给 DIRS 字段添加如下信息。 配置5 配置静态文件目录现在项目的根目录下创建一个 static 目录，之后在“settings.py”文件中进行配置。 配置6 到这里，就可以在应用中编写models，生成迁移：python manage.py makemigrations 应用名 ，执行迁移：python manage.py migrate ，编写views ，修改urls ，创建template 来实现自己的Web应用了。 当然，如果需要添加自己定义的中间件也可以在 “setting.py” 文件中的 MIDDLEWARE 中进行添加；如果需要保存用户上传的图片、音视频文件也是要在 “setting.py” 文件中添加配置（一般写在配置静态文件的后面）： 1234# 现在项目根目录下创建 media 目录# 配置上传的媒体文件路径 （图片、音视频）MEDIA_URL = '/media/'MEDIA_ROOT = os.path.join(BASE_DIR, 'media') 123456# 在项目目录下的urls中配置：from django.contrib.staticfiles.urls import staticfrom stu_pro.settings import MEDIA_URL, MEDIA_ROOT......urlpatterns += static(MEDIA_URL, document_root=MEDIA_ROOT) 还有在开发环境中要将 “setting.py” 文件中的 DEBUG 设置为 True ，表示启用Debug模式，这样可以详细的看到在在开发过程中出现的错误，以便于修改。在生产环境中将 DEBUG 设置为 False 。此外还有 ALLOWED_HOSTS 表示允许访问的主机列表，一般设为ALLOWED_HOSTS = [&#39;*&#39;] 。 还有一个最重要的，就是日志，也需要在 “setting.py” 中进行配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 创建存储日志文件地址LOG_PATH = os.path.join(BASE_DIR, 'log')# 判断log目录存不存在，不存在就创建if not os.path.exists(LOG_PATH): os.mkdir(LOG_PATH)# 配置日志LOGGING = &#123; # version 只能为1 'version': 1, # disable_existing_loggers 的值默认为True，那么配置中的所有 logger 都将被禁用 # logger 的禁用与删除不同，logger任然存在，但是将默默丢弃任何传递给它的信息，也不会传播到上一级 'disable_existing_loggers': False, 'formatters': &#123; 'verbose': &#123; 'format': '%(levelname)s %(asctime)s %(module)s %(process)s %(thread)s %(message)s' &#125;, 'simple': &#123; 'format': '%(levelname)s %(message)s' &#125; &#125;, 'handlers': &#123; 'stu_handlers': &#123; # 如果loggers的处理级别小于handlers的处理级别，则handler忽略该信息 'level': 'DEBUG', # 指定文件类型为RotatingFileHandler，当日志文件大小超过maxBytes后，会自动切割 'class': 'logging.handlers.RotatingFileHandler', # 输出文件地址 'filename': '%s/log.txt' % LOG_PATH, # 使用哪一种日志配置格式 'formatter': 'verbose', # 指定每个日志文件的大小 'maxBytes': 1024 * 1024 * 5 &#125; &#125;, 'loggers':&#123; 'console': &#123; 'handlers': ['stu_handlers'], 'level': 'INFO', # propagate=0，表示输出日志，但不传递消息 # propagate=1，表示输出日志，同时消息往更高级别的地方传递。root为最高级别。 'propagate': False &#125; &#125;&#125; logging模块可以收集记录错误，警告等调试信息，在程序中可以捕获这些信息，并且甚至可以将错误的重要信息等都可以通过邮件发送给开发者。 logging的组成： 1234LoggersHandlersFiltersFormatters Loggers： Logger 为日志系统的入口。每个logger 是一个具名的容器，可以向它写入需要处理的消息。 每个logger 都有一个日志级别。日志级别表示该logger 将要处理的消息的严重性。 Python 定义以下几种日志级别： 12345DEBUG：用于调试目的的底层系统信息INFO：普通的系统信息WARNING：表示出现一个较小的问题。ERROR：表示出现一个较大的问题。CRITICAL：表示出现一个致命的问题。 日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET Handlers： Handler 决定如何处理logger 中的每条消息。它表示一个特定的日志行为。 与logger 一样，handler 也有一个日志级别。如果消息的日志级别小于handler 的级别，handler 将忽略该消息。 Logger 可以有多个handler，而每个handler 可以有不同的日志级别。 Filters： Filter 用于对从logger 传递给handler 的日志记录进行额外的控制。 Formatters： 日志记录需要转换成文本。 Formatter 表示文本的格式。Fomatter 通常由包含日志记录属性的Python 格式字符串组成； 你也可以编写自定义的fomatter 来实现自己的格式。 django_logging1","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"Django -- 创建第一个Django项目","slug":"Django----创建第一个Django项目","date":"2018-05-21T16:00:00.000Z","updated":"2018-06-25T07:36:44.770Z","comments":true,"path":"2018/05/22/Django----创建第一个Django项目/","link":"","permalink":"http://alexyanglong.github.io/2018/05/22/Django----创建第一个Django项目/","excerpt":"","text":"Django – 创建第一个Django项目在开始创建Django项目之前，先要理解两个概念：请求与响应、MVC（在Django中称为MTV）。 什么是请求与响应请求：又称为HTTP请求，指从客户端到服务器端的请求消息。包括：请求行、请求头、消息体。消息行中，有对资源的请求方法、资源的标识符及使用的协议。例如： 1POST http://xg.mediportal.com.cn/health/sms/verify/telephone HTTP/1.1 请求头中包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。例如： 123456User-Agent: DGroupPatient/1.052701.230/Dalvik/2.1.0 (Linux; U; Android 5.1.1; KIW-AL10 Build/HONORKIW-AL10)Content-Type: application/x-www-form-urlencoded; charset=UTF-8Host: xg.mediportal.com.cnConnection: Keep-AliveAccept-Encoding: gzipContent-Length: 33 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户端要向服务器端发送的信息，当然如果不需要向服务器端发送信息，也可以没有。例如： 12telephone=15527177736&amp;userType=1&amp; 响应：也成为HTTP响应，指从服务器端到客户端的响应消息。与HTTP请求相似，HTTP响应也由3个部分构成，分别是：状态行、响应头、响应正文。状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。例如： 1HTTP/1.1 200 OK 响应头主要包含服务器发送的数据相关信息，比如返回数据的类型、长度等等。例如： 12345678Date: Tue, 31 May 2016 02:09:24 GMTContent-Type: application/json;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingAccess-Control-Allow-Origin: *Access-Control-Allow-Headers: X-Requested-With,access_token,access-token,content-type,multipart/form-data,application/x-www-form-urlencodedAccess-Control-Allow-Methods: GET,POST,OPTIONSContent-Length: 49 响应头和响应正文之间也有一个空行，表示响应头结束。响应正文包含了服务器端向客户端发送的数据。例如： 12&#123;&quot;resultCode&quot;:1,&quot;resultMsg&quot;:&quot;手机号未注册&quot;&#125; 通过下面的图理解请求与响应的流程： 请求与响应 什么是MVCMVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 目标：将模型（数据）和视图（显示）解耦合。 通过控制器，将数据和显示分离，好处是同一个视图可以加载不同的模型，同一个模型也可以显示成不同的视图。 稍具规模的系统都会使用MVC架构或者它的变体（MVP、MVVM等）。 通过下面的图来理解MVC的工作模式： MVC 在Django中将这种模式称为MTV ：模型（Model）- 模板（Template，对应视图） - 视图（View，对应控制器） 创建第一个Django项目Windows下步骤： （在黑屏终端中执行） python -m venv 虚拟环境名 创建项目虚拟环境 cd 虚拟环境文件名/Scripts 进入虚拟环境 activate.bat 激活虚拟环境 pip install django==版本号 在虚拟环境下安装django django-admin --version 查看版本 django-admin startproject 项目名 . 创建django项目 python manage.py runserver 开启服务 Linux下步骤： mk 项目目录 创建django项目目录 cd 项目目录 进入项目目录 python -m venv 虚拟环境名 创建项目虚拟环境 source 虚拟环境目录/bin/activate 激活虚拟环境 python -m pip install --upgrade pip 更新pip pip install django==版本号 在虚拟环境下安装django django-admin --version 查看版本 django-admin startproject 项目名 . 创建django项目 python manage.py runserver 开启服务 开启了服务之后，在浏览器中输入 127.0.0.1:8000 或 localhost:8000 回车，出现Django界面，第一个Django项目就创建成功了。如下图： Django运行","categories":[{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Django","slug":"Django","permalink":"http://alexyanglong.github.io/tags/Django/"}]},{"title":"使用Python代码操作Redis","slug":"使用Python代码操作Redis","date":"2018-05-18T16:00:00.000Z","updated":"2018-06-05T11:29:34.404Z","comments":true,"path":"2018/05/19/使用Python代码操作Redis/","link":"","permalink":"http://alexyanglong.github.io/2018/05/19/使用Python代码操作Redis/","excerpt":"","text":"使用Python代码操作RedisRedis是一款非关系型存储数据库，具有读取速度快的特性，所以常用于做高速缓存。 连接Redis123456789101112131415161718import redisdef main(): config = &#123; 'host': 'localhost', # redis服务器地址 'port': 6379, # redis服务器端口 'db': 0, # 使用的数据库编号 'password': '123456' # 密码 &#125; client = redis.Redis(**config) if client.ping(): # 判断是否连接成功 client.set('name', 'alex') print(client.get('name')) # b'alex'if __name__ == '__main__': main() 在这里我们使用redis.Redis连接本地Redis服务，传入的四个参数分别为Redis的地址、运行端口、使用的数据库、密码，这里使用的Redis其实是继承了StrictRedis，所以在默认情况下不传这四个参数时，参数值会有默认值分别为localhost、6379、0、None。 在Python中使用Redis其实很方便，Redis操作数据的命令(命令详细情况可以参照Redis命令参考)在Python中都能找到相应的方法，这里引用崔庆才老师对Redis的总结，介绍了Key(键)、String(字符串)、Hash(哈希表)、List(列表)、Set(集合)、SortedSet(有序集合)的相关操作。 Key(键) 方法 作用 参数说明 示例 示例说明 示例结果 exists(name) 判断一个key是否存在 name: key名 redis.exists(‘name’) 是否存在name这个key True delete(name) 删除一个key name: key名 redis.delete(‘name’) 删除name这个key 1 type(name) 判断key类型 name: key名 redis.type(‘name’) 判断name这个key类型 b’string’ keys(pattern) 获取所有符合规则的key pattern: 匹配规则 redis.keys(‘n*’) 获取所有以n开头的key [b’name’] randomkey() 获取随机的一个key randomkey() 获取随机的一个key b’name’ rename(src, dst) 将key重命名 src: 原key名 dst: 新key名 redis.rename(‘name’, ‘nickname’) 将name重命名为nickname True dbsize() 获取当前数据库中key的数目 dbsize() 获取当前数据库中key的数目 100 expire(name, time) 设定key的过期时间，单位秒 name: key名 time: 秒数 redis.expire(‘name’, 2) 将name这key的过期时间设置2秒 True ttl(name) 获取key的过期时间，单位秒，-1为永久不过期 name: key名 redis.ttl(‘name’) 获取name这key的过期时间 -1 move(name, db) 将key移动到其他数据库 name: key名 db: 数据库代号 move(‘name’, 2) 将name移动到2号数据库 True flushdb() 删除当前选择数据库中的所有key flushdb() 删除当前选择数据库中的所有key True flushall() 删除所有数据库中的所有key flushall() 删除所有数据库中的所有key True String(字符串) 方法 作用 参数说明 示例 示例说明 示例结果 set(name, value) 给数据库中key为name的string赋予值value name: key名 value: 值 redis.set(‘name’, ‘Bob’) 给name这个key的value赋值为Bob True get(name) 返回数据库中key为name的string的value name: key名 redis.get(‘name’) 返回name这个key的value b’Bob’ getset(name, value) 给数据库中key为name的string赋予值value并返回上次的value name: key名 value: 新值 redis.getset(‘name’, ‘Mike’) 赋值name为Mike并得到上次的value b’Bob’ mget(keys, *args) 返回多个key对应的value keys: key的列表 redis.mget([‘name’, ‘nickname’]) 返回name和nickname的value [b’Mike’, b’Miker’] setnx(name, value) 如果key不存在才设置value name: key名 redis.setnx(‘newname’, ‘James’) 如果newname这key不存在则设置值为James 第一次运行True，第二次False setex(name, time, value) 设置可以对应的值为string类型的value，并指定此键值对应的有效期 name: key名 time: 有效期 value: 值 redis.setex(‘name’, 1, ‘James’) 将name这key的值设为James，有效期1秒 True setrange(name, offset, value) 设置指定key的value值的子字符串 name: key名 offset: 偏移量 value: 值 redis.set(‘name’, ‘Hello’) redis.setrange(‘name’, 6, ‘World’) 设置name为Hello字符串，并在index为6的位置补World 11，修改后的字符串长度 mset(mapping) 批量赋值 mapping: 字典 redis.mset({‘name1’: ‘Durant’, ‘name2’: ‘James’}) 将name1设为Durant，name2设为James True msetnx(mapping) key均不存在时才批量赋值 mapping: 字典 redis.msetnx({‘name3’: ‘Smith’, ‘name4’: ‘Curry’}) 在name3和name4均不存在的情况下才设置二者值 True incr(name, amount=1) key为name的value增值操作，默认1，key不存在则被创建并设为amount name: key名 amount:增长的值 redis.incr(‘age’, 1) age对应的值增1，若不存在则会创建并设置为1 1，即修改后的值 decr(name, amount=1) key为name的value减值操作，默认1，key不存在则被创建并设置为-amount name: key名 amount:减少的值 redis.decr(‘age’, 1) age对应的值减1，若不存在则会创建并设置为-1 -1，即修改后的值 append(key, value) key为name的string的值附加value key: key名 redis.append(‘nickname’, ‘OK’) 向key为nickname的值后追加OK 13，即修改后的字符串长度 substr(name, start, end=-1) 返回key为name的string的value的子串 name: key名 start: 起始索引 end: 终止索引，默认-1截取到末尾 redis.substr(‘name’, 1, 4) 返回key为name的值的字符串，截取索引为1-4的字符 b’ello’ getrange(key, start, end) 获取key的value值从start到end的子字符串 key: key名 start: 起始索引 end: 终止索引 redis.getrange(‘name’, 1, 4) 返回key为name的值的字符串，截取索引为1-4的字符 b’ello’ Hash(哈希表)Hash，即哈希，可以用name指定一个哈希表的名称，然后表内存储了各个键值对，用法总结如下： 方法 作用 参数说明 示例 示例说明 示例结果 hset(name, key, value) 向key为name的hash中添加映射 name: key名 key: 映射键名 value: 映射键值 hset(‘price’, ‘cake’, 5) 向key为price的hash中添加映射关系，cake的值为5 1，即添加的映射个数 hsetnx(name, key, value) 向key为name的hash中添加映射，如果映射键名不存在 name: key名 key: 映射键名 value: 映射键值 hsetnx(‘price’, ‘book’, 6) 向key为price的hash中添加映射关系，book的值为6 1，即添加的映射个数 hget(name, key) 返回key为name的hash中field对应的value name: key名 key: 映射键名 redis.hget(‘price’, ‘cake’) 获取key为price的hash中键名为cake的value 5 hmget(name, keys, *args) 返回key为name的hash中各个键对应的value name: key名 keys: 映射键名列表 redis.hmget(‘price’, [‘apple’, ‘orange’]) 获取key为price的hash中apple和orange的值 [b’3’, b’7’] hmset(name, mapping) 向key为name的hash中批量添加映射 name: key名 mapping: 映射字典 redis.hmset(‘price’, {‘banana’: 2, ‘pear’: 6}) 向key为price的hash中批量添加映射 True hincrby(name, key, amount=1) 将key为name的hash中映射的value增加amount name: key名 key: 映射键名 amount: 增长量 redis.hincrby(‘price’, ‘apple’, 3) key为price的hash中apple的值增加3 6，修改后的值 hexists(name, key) key为namehash中是否存在键名为key的映射 name: key名 key: 映射键名 redis.hexists(‘price’, ‘banana’) key为price的hash中banana的值是否存在 True hdel(name, *keys) key为namehash中删除键名为key的映射 name: key名 key: 映射键名 redis.hdel(‘price’, ‘banana’) 从key为price的hash中删除键名为banana的映射 True hlen(name) 从key为name的hash中获取映射个数 name: key名 redis.hlen(‘price’) 从key为price的hash中获取映射个数 6 hkeys(name) 从key为name的hash中获取所有映射键名 name: key名 redis.hkeys(‘price’) 从key为price的hash中获取所有映射键名 [b’cake’, b’book’, b’banana’, b’pear’] hvals(name) 从key为name的hash中获取所有映射键值 name: key名 redis.hvals(‘price’) 从key为price的hash中获取所有映射键值 [b’5’, b’6’, b’2’, b’6’] hgetall(name) 从key为name的hash中获取所有映射键值对 name: key名 redis.hgetall(‘price’) 从key为price的hash中获取所有映射键值对 {b’cake’: b’5’, b’book’: b’6’, b’orange’: b’7’, b’pear’: b’6’} List(列表)列表内的元素可以重复，而且可以从两端插入和取值。 方法 作用 参数说明 示例 示例说明 示例结果 rpush(name, *values) 在key为name的list尾添加值为value的元素，可以传多个 name: key名 values: 值 redis.rpush(‘list’, 1, 2, 3) 给list这个key的list尾添加1、2、3 3，list大小 lpush(name, *values) 在key为name的list头添加值为value的元素，可以传多个 name: key名 values: 值 redis.lpush(‘list’, 0) 给list这个key的list头添加0 4，list大小 llen(name) 返回key为name的list的长度 name: key名 redis.llen(‘list’) 返回key为list的列表的长度 4 lrange(name, start, end) 返回key为name的list中start至end之间的元素 name: key名 start: 起始索引 end: 终止索引 redis.lrange(‘list’, 1, 3) 返回起始为1终止为3的索引范围对应的list [b&#39;3&#39;, b&#39;2&#39;, b&#39;1&#39;] ltrim(name, start, end) 截取key为name的list，保留索引为start到end的内容 name:key名 start: 起始索引 end: 终止索引 ltrim(‘list’, 1, 3) 保留key为list的索引为1到3的元素 True lindex(name, index) 返回key为name的list中index位置的元素 name: key名 index: 索引 redis.lindex(‘list’, 1) 返回key为list的列表index为1的元素 b’2’ lset(name, index, value) 给key为name的list中index位置的元素赋值，越界则报错 name: key名 index: 索引位置 value: 值 redis.lset(‘list’, 1, 5) 将key为list的list索引1位置赋值为5 True lrem(name, count, value) 删除count个key的list中值为value的元素 name: key名 count: 删除个数 value: 值 redis.lrem(‘list’, 2, 3) 将key为list的列表删除2个3 1，即删除的个数 lpop(name) 返回并删除key为name的list中的首元素 name: key名 redis.lpop(‘list’) 返回并删除名为list的list第一个元素 b’5’ rpop(name) 返回并删除key为name的list中的尾元素 name: key名 redis.rpop(‘list’) 返回并删除名为list的list最后一个元素 b’2’ blpop(keys, timeout=0) 返回并删除名称为在keys中的list中的首元素，如果list为空，则会一直阻塞等待 keys: key列表 timeout: 超时等待时间，0为一直等待 redis.blpop(‘list’) 返回并删除名为list的list的第一个元素 [b’5’] brpop(keys, timeout=0) 返回并删除key为name的list中的尾元素，如果list为空，则会一直阻塞等待 keys: key列表 timeout: 超时等待时间，0为一直等待 redis.brpop(‘list’) 返回并删除名为list的list的最后一个元素 [b’2’] rpoplpush(src, dst) 返回并删除名称为src的list的尾元素，并将该元素添加到名称为dst的list的头部 src: 源list的key dst: 目标list的key redis.rpoplpush(‘list’, ‘list2’) 将key为list的list尾元素删除并返回并将其添加到key为list2的list头部 b’2’ Set(集合)集合中的元素都是不重复的。 方法 作用 参数说明 示例 示例说明 示例结果 sadd(name, *values) 向key为name的set中添加元素 name: key名 values: 值，可为多个 redis.sadd(‘tags’, ‘Book’, ‘Tea’, ‘Coffee’) 向key为tags的set中添加Book、Tea、Coffee三个内容 3，即插入的数据个数 srem(name, *values) 从key为name的set中删除元素 name: key名 values: 值，可为多个 redis.srem(‘tags’, ‘Book’) 从key为tags的set中删除Book 1，即删除的数据个数 spop(name) 随机返回并删除key为name的set中一个元素 name: key名 redis.spop(‘tags’) 从key为tags的set中随机删除并返回该元素 b’Tea’ smove(src, dst, value) 从src对应的set中移除元素并添加到dst对应的set中 src: 源set dst: 目标set value: 元素值 redis.smove(‘tags’, ‘tags2’, ‘Coffee’) 从key为tags的set中删除元素Coffee并添加到key为tags2的set True scard(name) 返回key为name的set的元素个数 name: key名 redis.scard(‘tags’) 获取key为tags的set中元素个数 3 sismember(name, value) 测试member是否是key为name的set的元素 name:key值 redis.sismember(‘tags’, ‘Book’) 判断Book是否为key为tags的set元素 True sinter(keys, *args) 返回所有给定key的set的交集 keys: key列表 redis.sinter([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的交集 {b’Coffee’} sinterstore(dest, keys, *args) 求交集并将交集保存到dest的集合 dest:结果集合 keys:key列表 redis.sinterstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的交集并保存为inttag 1 sunion(keys, *args) 返回所有给定key的set的并集 keys: key列表 redis.sunion([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的并集 {b’Coffee’, b’Book’, b’Pen’} sunionstore(dest, keys, *args) 求并集并将并集保存到dest的集合 dest:结果集合 keys:key列表 redis.sunionstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的并集并保存为inttag 3 sdiff(keys, *args) 返回所有给定key的set的差集 keys: key列表 redis.sdiff([‘tags’, ‘tags2’]) 返回key为tags的set和key为tags2的set的差集 {b’Book’, b’Pen’} sdiffstore(dest, keys, *args) 求差集并将差集保存到dest的集合 dest:结果集合 keys:key列表 redis.sdiffstore(‘inttag’, [‘tags’, ‘tags2’]) 求key为tags的set和key为tags2的set的差集并保存为inttag 3 smembers(name) 返回key为name的set的所有元素 name: key名 redis.smembers(‘tags’) 返回key为tags的set的所有元素 {b’Pen’, b’Book’, b’Coffee’} srandmember(name) 随机返回key为name的set的一个元素，但不删除元素 name: key值 redis.srandmember(‘tags’) 随机返回key为tags的set的一个元素 SortedSet(有序集合)有序集合，它相比集合多了一个分数字段，利用它可以对集合中的数据进行排序。 方法 作用 参数说明 示例 示例说明 示例结果 zadd(name, *args, **kwargs) 向key为name的zset中添加元素member，score用于排序。如果该元素存在，则更新其顺序 name: key名 args: 可变参数 redis.zadd(‘grade’, 100, ‘Bob’, 98, ‘Mike’) 向key为grade的zset中添加Bob，score为100，添加Mike，score为98 2，即添加的元素个数 zrem(name, *values) 删除key为name的zset中的元素 name: key名 values: 元素 redis.zrem(‘grade’, ‘Mike’) 从key为grade的zset中删除Mike 1，即删除的元素个数 zincrby(name, value, amount=1) 如果在key为name的zset中已经存在元素value，则该元素的score增加amount，否则向该集合中添加该元素，其score的值为amount name: key名 value: 元素 amount: 增长的score值 redis.zincrby(‘grade’, ‘Bob’, -2) key为grade的zset中Bob的score减2 98.0，即修改后的值 zrank(name, value) 返回key为name的zset中元素的排名（按score从小到大排序）即下标 name: key名 value: 元素值 redis.zrank(‘grade’, ‘Amy’) 得到key为grade的zset中Amy的排名 1 zrevrank(name, value) 返回key为name的zset中元素的倒数排名（按score从大到小排序）即下标 name: key名 value: 元素值 redis.zrevrank(‘grade’, ‘Amy’) 得到key为grade的zset中Amy的倒数排名 2 zrevrange(name, start, end, withscores=False) 返回key为name的zset（按score从大到小排序）中的index从start到end的所有元素 name: key值 start: 开始索引 end: 结束索引 withscores: 是否带score redis.zrevrange(‘grade’, 0, 3) 返回key为grade的zset前四名元素 [b’Bob’, b’Mike’, b’Amy’, b’James’] zrangebyscore(name, min, max, start=None, num=None, withscores=False) 返回key为name的zset中score在给定区间的元素 name:key名 min: 最低score max:最高score start: 起始索引 num: 个数 withscores: 是否带score redis.zrangeby score(‘grade’, 80, 95) 返回key为grade的zset中score在80和95之间的元素 [b’Amy’, b’James’] zcount(name, min, max) 返回key为name的zset中score在给定区间的数量 name:key名 min: 最低score max: 最高score redis.zcount(‘grade’, 80, 95) 返回key为grade的zset中score在80到95的元素个数 2 zcard(name) 返回key为name的zset的元素个数 name: key名 redis.zcard(‘grade’) 获取key为grade的zset中元素个数 3 zremrangebyrank(name, min, max) 删除key为name的zset中排名在给定区间的元素 name:key名 min: 最低位次 max: 最高位次 redis.zremran gebyrank(‘grade’, 0, 0) 删除key为grade的zset中排名第一的元素 1，即删除的元素个数 zremrangebyscore(name, min, max) 删除key为name的zset中score在给定区间的元素 name:key名 min: 最低score max:最高score redis.zremran gebyscore (‘grade’, 80, 90) 删除score在80到90之间的元素 1，即删除的元素个数","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"Redis","slug":"Redis","permalink":"http://alexyanglong.github.io/tags/Redis/"}]},{"title":"使用Python代码操作MySQL5.x数据库","slug":"使用Python代码操作MySQL5.x数据库","date":"2018-05-16T16:00:00.000Z","updated":"2018-06-05T11:11:32.564Z","comments":true,"path":"2018/05/17/使用Python代码操作MySQL5.x数据库/","link":"","permalink":"http://alexyanglong.github.io/2018/05/17/使用Python代码操作MySQL5.x数据库/","excerpt":"","text":"使用Python代码操作MySQL5.x数据库要使用Python代码操作数据库需要安装一个第三方库PyMySQL。（注：Python版本为3.x） 可以使用pip管理工具安装： 1pip install PyMySQL 连接MySQL数据库编写代码，连接数据库123456789# Connection 创建连接conn = pymysql.connect(host='localhost', user='root', password='root', database='test', port=3306, charset='utf8', autocommit=False, cursorclass: pymysql.cursors.DictCursor) host ：主机名/主机IP port ：端口 user ：MySQL的登录用户名 password ：MySQL的登录密码 database ：要使用的数据库，可以简写成 db charset ：连接数据库采用的字符编码 autocommit ：默认值是False，表示DML(数据操纵语言)不会自动提交，如果为True则会自动提交 cursorclass ：cursorclass设置cursor游标的类型，这里设置的是dict类型，表示查询返回的结果是以字典的方式，这一项是不必须的。 常用方法connection对象常用的方法： 1234cursor() 使用该连接创建并返回游标对象commit() 提交当前事务rollback() 回滚当前事务close() 关闭连接 cursor对象常用的方法和属性 123456execute(sql) 执行一个SQL命令fetchone() 取得结果集的下一行fetchmany(size) 获取结果集的下几行fetchall() 获取结果集中的所有行rowcount 返回数据条数或影响行数close() 关闭游标对象 使用Python代码实现增删改查在MySQL中建库建表12345678910-- 建库 testcreate database test default charset utf8;-- 切换/使用test库use test;-- 建表create table dept( dno int primary key, -- 部门编号 dname varchar(20) not null, -- 部门名称 dlocation varchar(20) not null -- 部门位置); 得到数据库连接12345678910111213def get_conn(): config = &#123; 'host': 'localhost', 'port': 3306, 'user': 'root', 'password': 'root', 'db': 'test', 'charset': 'utf8', 'autocommit': False, # 默认不自动提交 'cursorclass': pymysql.cursors.DictCursor # 设置游标的类型,查询返回的结果是以字典的方式 &#125; conn = pymysql.connect(**config) # **config 语法是将config字典拆分成键值对的形式 return conn 插入操作123456789101112131415161718192021222324252627282930313233def insert(): \"\"\" 插入 \"\"\" # 得到Connection(连接) / Cursor(游标) conn = get_conn() try: # 创建Cursor对象,支持上下文语法,可以放在with中 with conn.cursor() as cursor: # 向数据库发出sql语句 dno = input('部门编号:') dname = input('部门名称:') dloc = input('部门地址:') # 如果使用字符串格式化的方式来组装SQL语句，最大的风险是用被SQL注射攻击 # sql = \"insert into dept values (%d, '%s', '%s')\" % (dno, dname, dloc) # result = cursor.execute(sql) # result = cursor.execute('insert into dept values (%s, %s, %s)', (dno, dname, dloc)) # 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s result = cursor.execute( 'insert into dept values (%(dno)s, %(dname)s, %(dloc)s)', &#123;'dno': dno, 'dname': dname, 'dloc': dloc&#125; ) # print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行 print('成功插入', result, '条数据') # 如果事务中的所有操作全部成功了最后手动提交 conn.commit() except BaseException as e: print(e) # 如果事务操作有任何一个操作发生异常,那么就会回滚事务 conn.rollback() finally: conn.close() 修改操作12345678910111213141516171819202122def update(): \"\"\" 修改 \"\"\" conn = get_conn() try: with conn.cursor() as cursor: dno = input('部门编号:') dname = input('部门名称:') # 这个方式传参是以字典的方式,但是要注意的是在占位的时候用%(name)s result = cursor.execute( 'update dept set dname=%(dname)s where dno=%(dno)s', &#123;'dno': dno, 'dname': dname&#125; ) # print('成功插入', cursor.rowcount, '条数据') # 这里cursor.rowcount是获取到受影响的行 print('成功修改', result, '条数据') conn.commit() except BaseException as e: print(e) conn.rollback() finally: conn.close() 删除操作12345678910111213141516171819def delete(dno): \"\"\" 根据编号删除 :param dno: 编号 \"\"\" conn = get_conn() try: with conn.cursor() as cursor: dno = input('部门编号:') # 向数据库发出sql语句 # execute方法中占位后传参除了元组和字典外,还可以是列表 result = cursor.execute('delete from dept where dno=%s', [dno]) conn.commit() print('删除成功' if result == 1 else '删除失败') except Exception as e: print(e) conn.rollback() finally: conn.close() 查询操作12345678910111213141516171819202122def select(): \"\"\" 查询 \"\"\" conn = get_conn() try: # 创建Cursor对象 with conn.cursor() as cursor: # 向数据库发出sql语句 cursor.execute('select dno, dname, dlocation from dept') result = cursor.fetchone() # 程序中最好不要使用fetchall(),如果库中数据量很大,查询的性能就很低 while result: print(result) # 取出部门名称 # 在这里我上面连接数据时,使用了cursorclass参数,查询时返回的结果是以字典的方式 print(result['dname']) result = cursor.fetchone() except Exception as e: print(e) finally: conn.close() 上面就是对MySQL数据库简单的增删查改操作。 合并编写一个类，将上面的操作数据库的方法都包含在里面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class MySqlHelper(object): \"\"\"MySQLHelper\"\"\" def __init__(self, connect_config): \"\"\" 构造器 :param connect_config: 连接配置，传入一个dict \"\"\" self.connect_config = connect_config self.conn = None self.cursor = None def connect_db(self): \"\"\"创建数据库连接\"\"\" self.conn = pymysql.connect(**self.connect_config) # self.cursor = self.conn.cursor() def close_db(self): \"\"\"关闭数据库连接\"\"\" # if self.cursor: # self.cursor.close() if self.conn: self.conn.close() def execute_dql(self, sql, *, param=None): \"\"\" 执行dql操作，即 select 语句 :param sql: sql语句，string :param param: 参数列表，dict :return: 查询结果，tuple \"\"\" # res = '' try: self.connect_db() with self.conn.cursor() as self.cursor: self.cursor.execute(sql, param) res = self.cursor.fetchall() except BaseException as e: print(e) finally: self.close_db() return res def execute_dml(self, sql, *, param=None): \"\"\" 执行dql操作，即 update、delete、insert 语句 :param sql: sql语句，string :param param: 参数列表，dict :return: 查询结果，int [1：成功，0：正常失败，-1：错误失败] \"\"\" try: self.connect_db() with self.conn.cursor() as self.cursor: count = self.cursor.execute(sql, param) self.conn.commit() if count: res = 1 else: res = 0 except BaseException as e: print(e) self.conn.rollback() res = -1 finally: self.close_db() return res 使用： 123456789101112131415161718192021222324252627def main(): config = &#123; 'host': 'localhost', 'user': 'root', 'password': 'root', 'database': 'test', 'port': 3306, 'charset': 'utf8', 'autocommit': False, 'cursorclass': pymysql.cursors.DictCursor # cursorclass设置cursor游标的类型，这里设置的是dict类型 &#125; sqlhelper = MySqlHelper(config) sql = 'select dno, dname, dlocation from dept where dno=%(no)s' param = &#123; 'no': 10 &#125; res = sqlhelper.execute_dql(sql, param=param) print(res) sql = 'insert into dept values (%(no)s, %(name)s, %(location)s)' param = &#123; 'no': 88, 'name': 'sda88', 'location': 'DSfcz88' &#125; res = sqlhelper.execute_dml(sql, param=param) print(res)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"MySQL","slug":"MySQL","permalink":"http://alexyanglong.github.io/tags/MySQL/"}]},{"title":"Linux防火墙服务firewalld的基本使用","slug":"Linux防火墙服务firewalld的基本使用","date":"2018-05-14T16:00:00.000Z","updated":"2018-06-07T08:22:13.426Z","comments":true,"path":"2018/05/15/Linux防火墙服务firewalld的基本使用/","link":"","permalink":"http://alexyanglong.github.io/2018/05/15/Linux防火墙服务firewalld的基本使用/","excerpt":"","text":"Linux防火墙服务firewalld的基本使用​ 防火墙是一种位于内部网络与外部网络之间的网络安全系统。一项信息安全的防护系统，依照特定的规则，允许或是限制传输的数据通过。防火墙通常工作在网络层，即IPv4或IPv6的IP包上。 什么是firewalld​ firewalld即Dynamic Firewall Manager of Linux systems，Linux系统的动态防火墙管理器。firewalld是一个服务，用于配置网络连接，从而哪些内外部网络的数据包可以允许穿过网络或阻止穿过网络。 ​ firewalld允许两种类型的配置：永久类型和运行时类型。运行时类型的配置在防火墙被重启后会丢失相应的规则配置；而永久类型的配置即使遇到系统重启，也会保留生效。 ​ 对应于上面两种类型的配置，firewalld相应的有两个目录：针对运行时类型配置的目录/usr/lib/firewall；以及针对永久类型配置的目录/etc/firewall。 firewalld的基本使用启动服务： systemctl start firewalld.service 或 systemctl start firewalld 查看状态：systemctl status firewalld.service 或 systemctl status firewalld 停止服务：systemctl stop firewalld.service 或 systemctl stop firewalld 重启服务：systemctl restart firewalld.service 或 systemctl restart firewalld 设置开机自启：systemctl enable firewalld.service 或 systemctl enable firewalld 取消开机自启：systemctl disable firewalld.service 或 systemctl disable firewalld 查看是否开机自启：systemctl is-enabled firewalld.service 或 systemctl is-enabled firewalld systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。 使用firewalld-cmd配置防火墙查看版本： firewall-cmd --version 查看帮助：firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口： firewall-cmd --zone=public --list-ports 重新加载防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态：firewall-cmd --panic-off 查看是否拒绝： firewall-cmd --query-panic 如何添加/删除一个端口（在防火墙上凿洞）添加端口（凿洞） 1firewall-cmd --zone=public --add-port=端口/tcp --permanent –permanent永久生效，没有此参数重启后失效 重新载入防火墙配置 1firewall-cmd --reload 查看端口在防火墙配置中的状态 1firewall-cmd --zone= public --query-port=端口/tcp 删除端口 1firewall-cmd --zone= public --remove-port=端口/tcp --permanent","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"firewalld","slug":"firewalld","permalink":"http://alexyanglong.github.io/tags/firewalld/"}]},{"title":"在Linux（CentOS7）下安装Redis","slug":"在Linux（CentOS7）下安装Redis","date":"2018-05-12T16:00:00.000Z","updated":"2018-06-05T02:34:12.424Z","comments":true,"path":"2018/05/13/在Linux（CentOS7）下安装Redis/","link":"","permalink":"http://alexyanglong.github.io/2018/05/13/在Linux（CentOS7）下安装Redis/","excerpt":"","text":"在Linux（CentOS7）下安装RedisRedis是一款非关系型存储数据库。 1、下载软件归档压缩包从redis官网上下载软件归档压缩包 1wget http://download.redis.io/releases/redis-3.2.11.tar.gz 2、解压缩解归档12gunzip redis-3.2.11.tar.gztar -xvf redis-3.2.11.tar.gz 3、安装切换至redis解压目录，执行下列命令进行配置和安装 1make &amp;&amp; make install 4、配置redis.conf配置文件配置redis.conf配置文件，注意备份 4.1、绑定ip在命令模式下， 61gg 定位至61行，进行绑定ip [注意：使用内网ip，可以在末行模式下输入 :!ifconfig 查看内网ip] 4.2、配置端口在命令模式下， 84gg 定位至84行，配置端口，默认是 6379 4.3、配置连接密码在命令模式下输入 /requirepass 查找，按 n 查找下一个，大概在480行，修改后 保存退出 5、后台启动服务，并设置日志文件1redis-server 配置文件的路径/配置文件名 &gt; 日志文件 &amp; 需要停止后台服务，请先把redis放在前台运行 (使用jobs查看后台运行编号num，再使用fg %num就将编号是num的服务放在前台运行了)，再使用 Ctrl C 停止redis服务。或者使用 kill 进程编号 同样，如果要将前台运行的服务放到后台运行，先使用Ctrl Z，再使用jobs查看状态，是处于Stopped停止状态，之后使用bg %num就可以将编号是num的服务放在后台运行了 基准测试 1redis-benchmark -h ip -p 端口 -a 密码 6、连接redis123redis-cli -h ip [-p 端口号] - 端口号为默认的6379可以不写auth 密码 - 输入密码ping - 测试连接，回复pong成功","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Redis","slug":"Redis","permalink":"http://alexyanglong.github.io/tags/Redis/"}]},{"title":"在Linux（CentOS7）下安装MySQL5.x","slug":"在Linux（CentOS7）下安装MySQL5.x","date":"2018-05-11T16:00:00.000Z","updated":"2018-06-05T02:26:53.572Z","comments":true,"path":"2018/05/12/在Linux（CentOS7）下安装MySQL5.x/","link":"","permalink":"http://alexyanglong.github.io/2018/05/12/在Linux（CentOS7）下安装MySQL5.x/","excerpt":"","text":"在Linux（CentOS7）下安装MySQL5.xMySQL是一款数据库，用于存储数据。 1、先使用wget下载mysql安装包1wget https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 2、创建组、用户后面mysql就使用这个用户来运行（注意这也是mysql启动脚本中默认的用户，因此最好不要改名）。 12groupadd mysqluseradd -r -g mysql mysql - （使用-r参数表示mysql用户是一个系统用户，不能登录） 3、安装3.1 解压将前面得到的mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz 解压、解归档 12gunzip mysql-5.7.22-linux-glibc2.12-x86_64.tar.gztar -xvf mysql-5.7.22-linux-glibc2.12-x86_64.tar 将解压后的目录移动至 /usr/local ，并重命名为 mysql 1mv mysql-5.7.22-linux-glibc2.12-x86_64 /usr/local/mysql 此后 /usr/local/mysql 就是安装目录了 注意，如果mysql目录下没有data和tmp目录，手动新建，并修改权限 3.2 目录权限设置将mysql及其下所有的目录所有者和组均设为mysql 12cd /usr/local/mysqlchown mysql:mysql -R . 3.3 初始化1/usr/local/mysql/bin/mysqld --initialize --user=mysql --datadir=/usr/local/mysql/data --basedir=/usr/local/mysql 初始化成功后出现如下信息： 201x-xx-xxT07:10:13.583130Z 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. Please use –explicit_defaults_for_timestamp server option (see documentation for more details). 201x-xx-xx T07:10:13.976219Z 0 [Warning] InnoDB: New log files created, LSN=45790 201x-xx-xx T07:10:14.085666Z 0 [Warning] InnoDB: Creating foreign key constraint system tables. 201x-xx-xx T07:10:14.161899Z 0 [Warning] No existing UUID has been found, so we assume that this is the first time that this server has been started. Generating a new UUID: 1fa941f9-effd-11e5-b67d-000c2958cdc8. 201x-xx-xx T07:10:14.165534Z 0 [Warning] Gtid table is not ready to be used. Table ‘mysql.gtid_executed’ cannot be opened. 201x-xx-xx T07:10:14.168555Z 1 [Note] A temporary password is generated for root@localhost: xxxxxxxxx. 注意最后一行，它给了root一个初始密码(xxxxxxxxx)，后面要登录的时候要用到这个密码。 3.4 配置配置 /etc 下的 my.cnf 文件，如果没有请创建 12345678910[mysqld]basedir = /usr/local/mysqldatadir = /usr/local/mysql/dataport = 3306socket = /usr/local/mysql/tmp/mysql.sock sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client]socket = /usr/local/mysql/tmp/mysql.sock 4、后台运行服务端注意：请将{mysql} 替换成 您的mysql安装路径 1&#123;mysql&#125;/bin/mysqld_safe &amp; 使用ps -ef | grep mysql 或者 netstat -nap | grep 3306 - 查看进程 1&#123;mysql&#125;/bin/mysqladmin -uroot -p - 停止 如果出现错误，请检查前面几步是否出错。 5、设置mysql以服务运行并且开机启动将{mysql}/ support-files/mysql.server 拷贝为/etc/init.d/mysql并设置运行权限 12cp mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysql 把mysql注册为开机启动的服务 1chkconfig --add mysql 当然也可以手动进行服务的开启和关闭： 12/etc/init.d/mysql start/etc/init.d/mysql stop 6、连接客户端创建客户端的软链接 1ln -s &#123;mysql&#125;/bin/mysql /usr/local/bin/mysql 客户端连接 1mysql -u root -p 输入刚才的初始化密码进入 进入之后，修改密码 1mysql&gt; alter user &apos;root&apos;@&apos;localhost&apos; identified by &apos;您的新密码&apos;; 配置远程可以连接 123use mysql # 打开mysql数据库 update user set host=&apos;%&apos; where user=&apos;root&apos; and host=&apos;localhost&apos;; # 将host设置为%表示任何ip都能连接mysql，当然也可以将host指定为某个ip flush privileges; # 刷新权限表，使配置生效 关闭远程连接，恢复mysql的默认设置（只能本地连接） 1update user set host=&apos;localhost&apos; where user=&apos;root&apos;; #将host设置为localhost表示只能本地连接mysql 也可以添加一个用户名为aaa，密码为xxx，权限为%（表示任意ip都能连接）的远程连接用户 1grant all on *.* to &apos;aaa&apos;@&apos;%&apos; identified by &apos;xxx&apos;; 至此，MySQL5.7安装完毕。 当然也可以使用Mariadb，它是MySQL5.x的一个分支，命令用法和MySQL5.x是一样的，安装（可以使用yum安装）步骤如下： 1、在安装之前可以先搜索yum管理工具中有没有mariadb的软件包，在命令行下： yum search mariadb-server mariadb 2、如果存在，就可以使用yum管理工具来安装，在命令行下： yum install mariadb-server mariadb 等待安装完成 4、启动/停止/重启数据库服务 systemctl start/stop/restart mariadb 设置开机自启 systemctl enable mariadb 取消开机自启 systemctl disable mariadb 4、连接数据库 mysql -u root -p","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"MySQL","slug":"MySQL","permalink":"http://alexyanglong.github.io/tags/MySQL/"}]},{"title":"在Linux（CentOS7）下构建安装Python3.x","slug":"在Linux（CentOS7）下构建安装Python3.x","date":"2018-05-09T16:00:00.000Z","updated":"2018-06-05T02:27:46.176Z","comments":true,"path":"2018/05/10/在Linux（CentOS7）下构建安装Python3.x/","link":"","permalink":"http://alexyanglong.github.io/2018/05/10/在Linux（CentOS7）下构建安装Python3.x/","excerpt":"","text":"在Linux（CentOS7）下构建安装Python3.xLinux环境自带了Python 2.x版本，但是如果要使用3.x的版本，可以先在Python的官方网站下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。 1、安装依赖库因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败 1yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel 2、下载Python源代码并解压缩到指定目录123wget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xzxz -d Python-3.6.1.tar.xztar -xvf Python-3.6.1.tar 3、配置和安装先切换至Python源代码目录并执行下面的命令进行配置和安装。 123cd Python-3.6.1./configure --prefix=/usr/local/python36 --enable-optimizationsmake &amp;&amp; make install 4、创建软链接这样就可以直接通过python3直接启动Python解释器，pip管理工具，2to3转换工具。 123ln -s /usr/local/python36/bin/python3 /usr/bin/python3ln -s /usr/local/python36/bin/pip3 /usr/bin/pip3ln -s /usr/local/python36/bin/2to3 /usr/bin/2to3 5、测试123python3 - 进入python3.X的交互环境pip3 -V - 查看pip的版本2to3 - 查看2to3 如果没有报错，就安装成功。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"}]},{"title":"在Linux（CentOS7）下Git安装与简单使用","slug":"在Linux（CentOS7）下Git安装与简单使用","date":"2018-05-09T16:00:00.000Z","updated":"2018-06-05T09:33:41.979Z","comments":true,"path":"2018/05/10/在Linux（CentOS7）下Git安装与简单使用/","link":"","permalink":"http://alexyanglong.github.io/2018/05/10/在Linux（CentOS7）下Git安装与简单使用/","excerpt":"","text":"在Linux（CentOS7）下Git安装与简单使用安装下载与解压123wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.17.0.tar.gztar -xvf git-2.17.0.tar.gzcd git-2.17.0 移除旧版本1yum remove git 安装依赖库12yum install libcurl-develyum install autoconf automake libtool 执行1make configure 显示： GIT_VERSION = 2.17.0 GEN configure 配置 1./configure --prefix=/usr/local/git --with-iconv --with-curl --with-expat=/usr/local/lib 构建安装 1make &amp;&amp; make install 配置环境变量1vim ~/.bash_profile 在文件末尾追加上下面命令: 12PATH=$PATH:/usr/local/git/binexport PATH 重新加载环境变量1source ~/.bash_profile 测试，查看git版本1git --version 出现Git的版本信息则安装成功。 简单使用建立本地仓库123mkdir &lt;directory&gt;cd &lt;directory&gt;git init 把文件纳入版本控制先将要进行版本控制的文件放入本地仓库，再将文件放入暂存区 123cd &lt;warehouse directory&gt;git add &lt;filename&gt; # 将修改后的文件加入暂存区或者 git add . # 将该目录下所有文件、目录加入暂存区 查看放入暂存区文件的状态1git status 提交暂存区文件到本地仓库1git commit -m &apos;本次提交文件的相关描述信息&apos; # -m 后面添加的是本次提交的描述 如果提交报错,看否是没有配置全局用户名和邮箱（user.name、user.email ），可执行下面的命令解决: 12git config --global user.name &apos;your-name&apos;git config --global user.email &apos;your-email&apos; 查看日志1git log 回滚到某个版本1git reset --hard 版本号 # 版本号可在日志文件中查看 显示版本包括历史版本12git refloggit reflog --pretty=oneline # 单行显示 撤回暂存区内容把暂存区的内容全撤回来(可以在本地做修改，然后再次add进暂存区做提交) 12git checkout -- # 撤回所有暂存区的文件、目录，这样就可以重新修改内容，让后在添加、提交git checkout -- [文件/目录] # 将暂存区的该文件/目录撤回，这样就可以重新修改内容，让后在添加、提交 添加远端仓库1git remote add origin 远端仓库地址 将本地仓库和远端仓库同步1git push -u origin master 创建分支1git branch [branch name] 查看所有分支1git branch 切换分支1git checkout [branch name] 合并分支1git merge [branch name] 删除仓库中的文件1git rm [filename] 克隆项目到本地1git clone 远端仓库地址 推送到服务器提交到远程仓库，origin是原始名字，master是分支，第一次需要加参数 -u ，以后不用 123git push -u origin master或git push origin master 拉取服务器代码1git pull","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Git使用","slug":"Git使用","permalink":"http://alexyanglong.github.io/tags/Git使用/"}]},{"title":"在Linux（CentOS7）下安装Nginx服务器","slug":"在Linux（CentOS7）下安装Nginx服务器","date":"2018-05-09T16:00:00.000Z","updated":"2018-06-05T02:08:30.006Z","comments":true,"path":"2018/05/10/在Linux（CentOS7）下安装Nginx服务器/","link":"","permalink":"http://alexyanglong.github.io/2018/05/10/在Linux（CentOS7）下安装Nginx服务器/","excerpt":"","text":"在Linux（CentOS7）下安装Nginx服务器nginx是一款高性能的web服务器，在Linux中可以使用 yum 来安装，安装步骤如下： 1、检查yum包管理工具中有没有Nginx1yum search nginx 2、安装1yum install nginx 3、启动nginx服务器1nginx - 如果没有报错，就OK 4、测试在浏览器地址栏输入主机公网ip，进行测试查看。注意：先确保主机的80端口[web服务默认80端口]是开启的。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://alexyanglong.github.io/tags/Nginx/"}]},{"title":"Linux Shell的基本使用","slug":"Linux的基本使用","date":"2018-05-04T16:00:00.000Z","updated":"2018-06-05T02:45:32.650Z","comments":true,"path":"2018/05/05/Linux的基本使用/","link":"","permalink":"http://alexyanglong.github.io/2018/05/05/Linux的基本使用/","excerpt":"","text":"Linux Shell的基本使用 Linux简介 操作系统发展史图： 操作系统发展史 Linux的基本命令（centos7）who 或 w：查看当前登录的所有用户 who am i 或 whoami：查看当前登录用户 last：查看之前登录过的用户历史记录 clear：清屏 ps：查看进程状态 ​ ps -ef：查看进程 ​ ps -aux：查看进程 kill ： 进程号：杀掉进程 netstat -nap：查看进程、端口、进程号 adduser 用户名：创建新用户 userdel 用户名：删除用户 passwd [用户名]：修改用户密码，不加用户名是修改的root的密码 ssh 用户名@ip地址：远程安全连接其他的服务器 logout 或 exit：退出 reboot：重启服务器 shutdown：关闭服务器 init 0：关机 init 6：重启 uname：查看当前系统 hostname：查看主机名 history：查看历史命令，默认保存最近1000条，可以使用 HISTSIZE=新值 来修改保存的条数 ​ !num(命令行号)：重新执行改行命令 man 命令：查看’命令‘的使用方式 info 命令：查看’命令‘的使用方式，更详细 命令 --help：查看’命令‘的参数使用方法 whatis 命令：查看命令的简短描述 pwd：打印当前工作目录路径 - print working directory whereis 命令：查找包含 ’命令‘ 所有的目录路径 which 命令：查找到第一个含有 ’命令‘ 的目录路径 su 用户名：切换到该用户，但是不会切换到该用户的文件目录 su - 用户名：切换到该用户，并且切换到该用户的文件目录 sudo 命令操作：以管理员身份执行 mkdir 目录名：创建目录 rmdir 目录名：删除空目录 rm 目录名/文件名：删除目录或者文件，可以加参数 ​ -i：交互式删除，有提示 interactive ​ -f：不用提示，直接删除 force ​ -r：递归删除目录下的内容 recursive ls：查看当前目录下的所有文件和目录（非隐藏），可以加参数 ​ -l：查看当前目录下的所有文件和目录，长格式（非隐藏） ​ -a：查看当前目录下的所有文件和目录 ​ -al 或 -l -a：查看当前目录下的所有文件和目录，长格式 ​ -r：反转显示目录下的文件和目录，按字母表降序 ​ -R：递归显示目录下的文件和目录 touch 文件名：没有该文件就创建一个空文件，有只是改变其时间戳，可以修改文件的三个时间：修改内容的时间，更改权限的时间，最后访问的时间 cd 目录：切换目录 - change directory ​ cd /root：回到root主目录 （/root 绝对路径） （/root：root用户主目录，/etc：放置配置文件目录 /home：其他用户的用户主目录，/usr：用户数据、用户应用目录） ​ cd ~：回到当前用户主目录 ​ cd ..：回到上一级 ​ cd /：回到根目录 cp 文件名 路径：将文件拷贝到路径下，可以重命名 scp 本地文件 用户名@ip地址:路径：将本地文件安全拷贝到目标服务器的某路径下 sftp 用户名@ip地址：安全的远程文件传输 mv 文件名/目录 路径：将文件/目录剪切（移动）到路径下，可以重命名 cat 文件名：查看文件所有内容 ​ cat 文件名 -n：查看文件内容并显示行号 ​ cat 文件名| more 或 less：一页一页查看 ​ cat 文件名| grep pattern：搜索文件中的内容，匹配模式pattern匹配的字符串 head -n 文件：查看文件前 n 行 tail -n 文件：查看文件最后 n 行 wget 资源路径：联网获取资源 ​ wget -O filename 资源路径：获取资源并给资源重命名 grep pattern 文件1：搜索文件1中的内容，匹配模式pattern匹配的字符串 find：查找文件或目录 jobs：查看正在执行的后台任务列表 fg %n：将编号为 n 的后台任务拿到前台执行 bg %n：将编号为 n 的后台暂停任务继续在后台执行 top：查看CPU的状态 wc 文件：统计文件的行数、单词数、字符数，可以加参数 ​ -l：行数 ​ -w：单词数 uniq 文件：将文件中的内容去重显示，注意只能去相邻的重复的，不改变原文件内容 sort 文件：将文件中的内容进行排序显示，不改变原文件内容 diff 文件1 文件2：比较两个文件的差异，并显示不同之处 file 文件：显示文件的性质 date：查看当前时间 cal：查看日历 echo：回声命令 ​ echo string：在屏幕上输出string ​ echo string &gt; 文件：将string输出到文件中 ​ echo $a：在屏幕上打印变量a的值 ln：创建链接 ln 路径1/文件1 路径2/文件2：给路径1下的文件1在路径2下创建名为文件2的硬链接，存储的是文件1内容的引用，相当于备份，但是不会占用空间 ln -s 路径1/文件1 路径2/文件2：给路径1下的文件1在路径2下创建名为文件2的软链接，相当于快捷方式，不是引用 gzip 文件名：压缩 gunzip 文件名：解压缩 xz：压缩、解压缩，可以加参数 ​ xz -z 文件名：压缩 ​ -0 … -9：压缩比，值越大，压缩率越大 ​ xz -d 文件名：解压缩 tar：归档 ​ -x：抽取，解归档 ​ -v：显示解归档的过程 ​ -f：指定文件名 ​ tar -xvf 文件名：解归档使用 ​ -t：查看归档文件的内容 ​ -c：归档 ​ tar -cvf 归档文件名 源文件路径：归档使用 alias 名称=&#39;命令 [参数]&#39;：给 ‘命令 参数’ 起别名 unalias 名称：取消别名 !v：把刚刚以v开头的命令在执行一遍 &amp;：后台执行 >文件2：输出重定向，将运行结果输出到文件2 2&gt; 文件3：错误重定向，将错误输出到文件3 >&gt; 文件4：追加输出重定向，将运行结果追加输出到文件4 &lt;：输入重定向 vi / vim 编辑器的使用：i 或 a：进入编辑模式 ESC：退出编辑模式，进入命令模式 : ：在命令模式下，按 : 键进入末行模式 在命令模式下：yy：复制本行 num yy：复制num行 p：粘贴 dd：删除本行 num dd：删除num行 dw：删除一个单词 dG：删除所有内容 d$：从当前位置删除到行末尾 u：撤销 G：去到最后一行 num G：去到num行 gg：回到第一行 Ctrl y：向上翻一行 Ctrl e：向下翻一行 Ctrl f：向下翻一页 Ctrl b：向上翻一页 ZZ：保存并退出 在末行模式下：:!系统命令：在vim编辑器执行系统命令，执行完后回车，回到vim编辑器 eg： :!cal :wq：保存并退出 :q!：不保存退出 :set nu：显示行号 :set nonu：取消行号 :syntax off：关闭高亮语法 :syntax on：开启高亮语法 :set ts=4：将制表键设置为4个空格 /string：搜索string， 按 n 键向下搜索， 按 N 键向上搜索 :1,$s/string1/string2/g：将文件中从第一行到最后一行的所有string1换成string2 :inoremap 快捷键名 对应的代码 ：自定义快捷键 eg： :inoremap pymain if name == ‘main‘ 文件、目录权限：- rwx rwx rwx: 类型 所有者权限 同组用户权限 其他用户权限 类型：文件（-）、目录（d）、链接（l） r：read 4 - 0b(100) w：write 2 - 0b(10) x：excute 1 - 0b(1) chmod 权限 文件/目录：修改文件/目录的权限 chmod 777 文件/目录","categories":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://alexyanglong.github.io/tags/Linux/"}]},{"title":"JavaScript总结","slug":"JavaScript总结","date":"2018-04-27T16:00:00.000Z","updated":"2018-06-05T02:30:12.708Z","comments":true,"path":"2018/04/28/JavaScript总结/","link":"","permalink":"http://alexyanglong.github.io/2018/04/28/JavaScript总结/","excerpt":"","text":"JavaScript总结JavaScript： JS - Behavior ​ ECMAScript - 语法规范 - ES5 ​ BOM - 浏览器对象模型 - window ​ DOM - 文档对象模型 - document JavaScript 数据类型JavaScript 有隐式的类型转换。 ​ 简单数据类型： number、string、boolean、null、undefined ​ 复杂数据类型： object ​ 可以使用 typeof() 查看数据类型 JavaScript 运算符​ 算术运算符：+ 、-、 *、/、 % 、**（ES7版本） ​ 赋值运算符：= 、+=、 -=、 *=、 /=、%= ​ 比较（关系）运算符： &gt;、 &gt;=、 &lt;、 &lt;=、 ==、 != 、===（不带隐式类型转换的等于，全等于）、!==（严格不等于） ​ 逻辑运算符： &amp;&amp;（短路与）、 ||（短路或）、 ! ​ 自增自减运算符： ++ 、-- ​ 位运算、成员运算 JavaScript 中的全局函数isNaN() 判断是不是 不是一个数 parseInt() 取整，如果取不出，返回NaN parseFloat() 取小数，如果取不出，返回NaN isFinite() 判断是不是有限的数 eval() - evaluate - 容易引发XSS（跨站脚本攻击） encodeURIcomponent() 编成 百分号 编码 decodeURIcomponent() 从百分号编码 解码 获取对象获取的对象元素： document.getElementById(#id) document.getElementByClassName(.class) document.getElementByTagName(标签) querySelector() ： 根据指定的选择器查找单个元素 querySelectorAll() ： 根据指定的选择器查找所有元素 this // this 表示引发当前事件的对象元素 // evt 表示当前事件，evt.target 表示引发当前事件的事件源 // 需要在函数参数中 传入evt 对象 evt = evt || window.event; // 兼容低版本的IE var target = evt.target || evt.srcElement; 在定义函数时，如果没有传入参数，那么函数中有一个隐藏的 arguments 对象，它代表了参数的列表，在调用时，可以传入任意多个参数。 12345function foo()&#123; for (var i = 0;i &lt; arguments.length;i++)&#123; alert(arguments[i]); &#125;&#125; window对象document 文档 location 地址栏 - href / reload / replace history 历史记录 - go / forward / back navigator 浏览器 screen 操作系统窗口 - availWidth/ availHeight / width / height alert /confirm / prompt open / close setTimeout / setInterval / clearTimeout / clearInterval 修改节点的内容和属性 textContent innerHTML nodeValue 访问成员运算符 . setAttribute / getAttribute / removeAttribute 创建新节点 createElement 追加新节点 appendChild insertBefore 移除子节点 removeChild 通过自己节点访问父节点 parentNode 通过自己节点访问子节点 children 所有 firstChild 第一个 lastChild 最后一个 通过自己节点访问兄弟节点 nextSibling 前面的兄弟 prevSibling 后面的兄弟 JQueryjQuery的$函数的作用: 1、$(function() {}) $() 函数传入的是一个函数，表示该函数是在页面加载完成之后要执行的回调函数 2、$(selector) $() 函数传入的是一个选择器，表示通过选择器获得对应的元素，并处理成 jQuery对象，jQuery对象的本质是一个数组，如果要将jQuery对象转成原生js对象，使用下标或者get() 运算 3、$(element) $() 函数传入的是一个原生js对象，表示将其转成jQuery对象 4、$(标签) $() 函数传入的是一个标签，表示创建对应的元素并处理成jQuery对象 注意：当jQuery库和其他的库中的 $函数 有冲突，可以使用以下方法解决： ​ jQuery.noConflict() 将jQuery库中的 $函数 不起作用，但是jQuery库可以使用jQuery来替代 $，其他库可以使用 $函数。 查找元素 选择器 * / element / #id / .class / selector1, selector2 ancestor descendant / parent&gt;child / previous+next / previous~siblings 筛选器 基本筛选器：:not(selector)/ :first / :last / :even / :odd / :eq(index) / :gt(index) / :lt(index) / :animated / :focus 内容筛选器：:contains(&#39;…&#39;)/ :empty / :parent / :has(selector) 可见性筛选器：:hidden / :visible 子节点筛选器：:nth-child(expr) / :first-child / :last-child / :only-child 属性筛选器：[attribute] / [attribute=&#39;value&#39;] / [attribute!=&#39;value&#39;] / [attribute^=&#39;value&#39;] / [attribute$=&#39;value&#39;] / [attribute|=&#39;value&#39;] / [attribute~=&#39;value&#39;] 表单： :input / :text / :password / :radio / :checkbox / :submit / :image / :reset / :button / :file / :selected / :enabled / :disabled / :checked 执行操作 内容操作 获取/修改内容：html() / text() / replaceWith() / remove() 获取/设置元素：before() / after() / prepend() / append() / remove() / clone() / unwrap() / detach() / empty() / add() 获取/修改属性：attr() / removeAttr() / addClass() / removeClass() / css() 获取/设置表单值：val() 查找操作 查找方法：find() / parent() / children() / siblings() / next() / nextAll() / prev() / prevAll() 筛选器：filter() / not() / has() / is() / contains() 索引编号：eq() 尺寸和位置 尺寸相关：height() / width() / innerHeight() / innerWidth() / outerWidth() / outerHeight() 位置相关：offset() / position() / scrollLeft() / scrollTop() 特效和动画 基本动画：show() / hide() / toggle() 消失出现：fadeIn() / fadeOut() / fadeTo() / fadeToggle() 滑动效果：slideDown() / slideUp() / slideToggle() 自定义：delay() / stop() / animate() 事件 文档加载：ready() / load() 用户交互：on() / off() AJAX - Asynchronous JavaScript and XML让浏览器向服务器发出异步请求(非阻塞式请求)，等服务器返回了响应数据(JSON/XML)后就可以对页面进行局部刷新，这样就可以在不中断用户体验的前提下刷新页面数据 123456789101112$.ajax(&#123; url: 向服务器发送请求的url type: 发送请求的类型（get、post、put、patch、delete等） data: 发送请求时需要向服务器提交的数据，不是必填项 datatype: 接收服务器返回数据的类型 success: function(data)&#123; 执行成功时，回调的函数 &#125;, error: function(error)&#123; 执行失败时，回调的函数 &#125;&#125;);","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://alexyanglong.github.io/categories/Web前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://alexyanglong.github.io/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://alexyanglong.github.io/tags/jQuery/"},{"name":"AJAX","slug":"AJAX","permalink":"http://alexyanglong.github.io/tags/AJAX/"}]},{"title":"HTML+CSS总结","slug":"HTML+CSS总结","date":"2018-04-24T16:00:00.000Z","updated":"2018-06-05T02:31:35.557Z","comments":true,"path":"2018/04/25/HTML+CSS总结/","link":"","permalink":"http://alexyanglong.github.io/2018/04/25/HTML+CSS总结/","excerpt":"","text":"HTML+CSS总结Web前端主要包含三部分内容： 1、Tag：HTML标签，用来装要显示的内容、数据。 2、CSS：Display，对要显示的内容进行渲染。 3、JavaScript：Behavior，交互、行为，使用户具有更好的体验。 HTML​ HTML （Hyper Text Markup Language，超文本标记语言）是用来描述网页的一种语言，它包含了一系列的标签。 ​ html：此标签可告知浏览器其自身是一个 HTML 文档。&lt;html&gt; 与 &lt;/html&gt; 标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。 ​ head：此标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。下面这些标签可用在 head 部分：&lt;base&gt; 、&lt;link&gt; 、&lt;meta&gt; 、&lt;style&gt; 、&lt;script&gt; 和 &lt;title&gt; 。&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。 ​ body：此标签定义文档的主体。包含文档的所有要进行显示的内容（比如文本&lt;span&gt; &lt;p&gt; 、上标&lt;sup&gt; 、下标&lt;sub&gt; 、超链接&lt;a&gt;、图像&lt;img&gt;、表格&lt;table&gt; 、列表&lt;ul&gt; &lt;ol&gt; &lt;dl&gt; 、逻辑语义块&lt;header&gt; &lt;section&gt; &lt;aside&gt; &lt;footer&gt; &lt;div&gt; 、标题&lt;h1&gt;~&lt;h6&gt; 、换行&lt;br&gt; 、内嵌块&lt;iframe&gt; 、表单元素&lt;form&gt; &lt;input&gt; &lt;button&gt; &lt;select&gt; 、音频&lt;audio&gt; 、视频&lt;video&gt;等等）。 ​ 除此之外，每个标签都有自己特有的属性，例如&lt;a&gt; 标签有href属性、每个标签都有的class属性等等。并且还支持自定义属性，即开发人员自己定义一个不存在的属性。 CSS​ CSS（Cascading Style Sheets，层叠样式表）是用来渲染HTML标签的显示样式的一种语言。根据CSS在HTML页面的位置的不同，可以分为三类： ​ 内部样式表：写在&lt;head&gt;的&lt;style&gt;标签内，多用于首页。加载快。 ​ 外部样式表：脱离HTML页面，写在外部，可以用于其他页面。所有页面可以共享同一个样式，便于风格统一；使内容和显示分离。 ​ 内嵌（行内）样式表：写在每个标签的style属性内，不常用。不易于扩展。 CSS选择器通配符选择器： * 标签选择器： &lt;标签名&gt; 类选择器： .class id选择器： #id 并列选择器：selector1 , selector2 后代选择器： 父 空格(所有后代)、父&gt;(儿子后代) 兄弟选择器： ~ (所有兄弟) 相邻兄弟选择器： + (必须是相邻兄弟) 标签使用哪个CSS样式进行渲染的三个原则：​ 1、就近原则： 哪个样式里标签更近就用哪个 ​ 2、具体性原则： #id选择器 &gt; .class选择器 &gt; 标签选择器 &gt; 通配符选择器 ​ 3、重要性原则： !important CSS盒子模型CSS模型：Box Model （盒模型 ） —— 由内到外： 内容 - padding - border - background-image - background-color - margin 标签常用的CSS样式边框border 设置对象边框的特性 border-color 设置或检索对象的边框颜色 字体font-size 设置字体大小 font-family 规定文本的字体 font-style 规定文本的字体样式 font-weight 规定字体的粗细 文本color 指定文本的颜色 line-height 设置行高 text-align 规定文本的水平对齐方式 text-decoration 规定添加到文本的装饰效果 内外边距padding 简写属性在一个声明中设置所有填充属性。该属性可以有1到4个值 padding-top padding-right padding-bottom padding-left margin 在一个声明中设置所有外边距属性，该属性可以有1到4个值 margin-top margin-right margin-bottom margin-left 背景background-color 设置或检索对象的背景颜色 background-image 设置或检索对象的背景图像 displaydisplay: none 此元素不会被显示。 display: block 此元素将显示为块级元素，此元素前后会带有换行符。 display: inline 此元素会被显示为内联元素，元素前后没有换行符。 display: inline-block 此元素会被显示为行内块元素，可以设置宽度、高度等，元素前后没有换行符。 具有hidden 属性的元素是不可见的。 CSS 定位position: static 正常文档流 position: relative 相对定位（相对于元素原来的位置，没有脱离文档流，对周围元素没有影响） position: absolute 绝对定位（相对于父元素来设定位置，脱离了文档流，对周围元素有影响） position: fixed 固定定位（相对于浏览器窗口来设定位置，脱离了文档流） CSS 设置字符集@charset : utf-8 CSS 设置字体： 1234@font-face &#123; font-family： ‘字体名称’ src：url(字体资源路径)&#125; CSS hack technology （CSS黑科技）z-index 索引，当脱离文档流时，元素显示优先级冲突，设置元素z-index属性值越大就渲染在越上方 在有浮动的情况下 ，为了让父级元素计算出它的高度的方法： 1、clear:both 清除浮动 2、在父元素的样式中加入 overflow：auto","categories":[{"name":"Web前端","slug":"Web前端","permalink":"http://alexyanglong.github.io/categories/Web前端/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://alexyanglong.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://alexyanglong.github.io/tags/CSS/"}]},{"title":"Python基础（14）——进程和线程","slug":"Python基础（14）——进程和线程","date":"2018-04-19T16:00:00.000Z","updated":"2018-06-05T02:05:10.727Z","comments":true,"path":"2018/04/20/Python基础（14）——进程和线程/","link":"","permalink":"http://alexyanglong.github.io/2018/04/20/Python基础（14）——进程和线程/","excerpt":"","text":"Python基础（14）——进程和线程线程：是操作系统分配CPU的基本单元 进程：是操作系统分配内存的基本单元，一个进程由一个或多个线程构成 多进程、多线程：加速程序执行，提升性能；改善用户体验 ​ 编写麻烦，调试更麻烦；对其他进程、线程不友好；占用更多资源 单进程 / 单线程模拟下载任务例子： 单线程模拟下载例子 多进程模拟下载任务例子： 多进程模拟下载例子 多线程模拟下载任务例子： 多线程模拟下载例子","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"线程","slug":"线程","permalink":"http://alexyanglong.github.io/tags/线程/"},{"name":"进程","slug":"进程","permalink":"http://alexyanglong.github.io/tags/进程/"}]},{"title":"Python基础（13）——网络编程入门","slug":"Python基础（13）——网络编程入门","date":"2018-04-16T16:00:00.000Z","updated":"2018-06-05T02:04:54.066Z","comments":true,"path":"2018/04/17/Python基础（13）——网络编程入门/","link":"","permalink":"http://alexyanglong.github.io/2018/04/17/Python基础（13）——网络编程入门/","excerpt":"","text":"Python基础（13）——网络编程入门基于传输层协议的套接字编程套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用C语言写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。 TCP套接字所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。 TCP提供了可靠地数据传输，主要基于以下机制： ​ 1、可靠通信[数据不传丢也不传错] 滑动窗口机制 ​ 2、流量控制(自动调节发送数据的速度 ​ 3、拥塞控制(网络拥堵时会降低发送速度) 服务器端程序： 12345678910111213141516171819202122232425262728293031from socket import socket, AF_INET, SOCK_STREAM, SOCK_DGRAMfrom datetime import datetimedef main(): # 1、创建套接字对象，并指定使用哪种传输服务 # AF_INET：IPV4 AF_INET6：IPV6 SOCK_STREAM: TCP SOCK_DGRAM: UDP SOCK_RAW: 原始套接字 server_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、绑定IP地址和端口，建议使用 1024 以后的端口 print('正在绑定IP地址和端口......') server_socket.bind(('10.7.152.89', 9999)) print('服务器绑定IP地址和端口成功') # 3、启动监听 监听客户端有没有连接到服务器 512：历史经验最佳值 print('正在启动服务器......') server_socket.listen(512) print('服务器启动成功') # 4、等待连接 通过循环等待客户端连接并作出相应处理 while True: # 阻塞并等待连接 client_socket, addr = server_socket.accept() print(str(addr) + '连接到了服务器.') # 5、发送数据 client_socket.send(str(datetime.now()).encode('utf-8')) # 6、断开连接 client_socket.close()if __name__ == '__main__': main() 客户端程序： 123456789101112131415161718from socket import socket, AF_INET, SOCK_STREAMdef main(): # 1、创建套接字 socket client_socket = socket(family=AF_INET, type=SOCK_STREAM) # 2、连接服务器 client_socket.connect(('10.7.152.89', 9999)) # 3、循环发送和接收信息 while True: info = client_socket.recv(1024).decode('utf-8') print(info) # client_socket.close()if __name__ == '__main__': main() UDP套接字传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"TCP编程","slug":"TCP编程","permalink":"http://alexyanglong.github.io/tags/TCP编程/"},{"name":"套接字编程","slug":"套接字编程","permalink":"http://alexyanglong.github.io/tags/套接字编程/"}]},{"title":"Python基础（12）——正则表达式","slug":"Python基础（12）——正则表达式","date":"2018-04-14T16:00:00.000Z","updated":"2018-06-05T02:04:39.062Z","comments":true,"path":"2018/04/15/Python基础（12）——正则表达式/","link":"","permalink":"http://alexyanglong.github.io/2018/04/15/Python基础（12）——正则表达式/","excerpt":"","text":"Python基础（12）——正则表达式正则的基本符号下面的表示总结了一些正则的基本符号： 符号 解释 示例 说明 . 匹配任意字符 b.t 可以匹配bat / but / b#t / b1t等 \\w 匹配字母/数字/下划线 b\\wt 可以匹配bat / b1t / b_t等但不能匹配b#t \\s 匹配空白字符（包括\\r、\\n、\\t等） love\\syou 可以匹配love you \\d 匹配数字 \\d\\d 可以匹配01 / 23 / 99等 \\b 匹配单词的边界 \\bThe\\b ^ 匹配字符串的开始 ^The 可以匹配The开头的字符串 \\ 匹配字符串的结束\\ .exe 可以匹配.exe结尾的字符串 \\W 匹配非字母/数字/下划线 b\\Wt 可以匹配b#t / b@t等但不能匹配but / b1t / b_t等 \\S 匹配非空白字符 love\\Syou 可以匹配love#you等但不能匹配love you \\D 匹配非数字 \\d\\D 可以匹配9a / 3# / 0F等 \\B 匹配非单词边界 \\Bio\\B [] 匹配来自字符集的任意单一字符 [aeiou] 可以匹配任一元音字母字符 [^] 匹配不在字符集中的任意单一字符 [^aeiou] 可以匹配任一非元音字母字符 * 匹配0次或多次 \\w* + 匹配1次或多次 \\w+ ? 匹配0次或1次 \\w? {N} 匹配N次 \\w{3} {M,} 匹配至少M次 \\w{3,} {M,N} 匹配至少M次至多N次 \\w{3,6} \\ 分支 foo\\ bar 可以匹配foo或者bar (?#) 注释 (exp) 匹配exp并捕获到自动命名的组中 (?exp) 匹配exp并捕获到名为name的组中 (?:exp) 匹配exp但是不捕获匹配的文本 (?=exp) 匹配exp前面的位置 \\b\\w+(?=ing) 可以匹配I’m dancing中的danc (?&lt;=exp) 匹配exp后面的位置 (?&lt;=\\bdanc)\\w+\\b 可以匹配I love dancing and reading中的第一个ing (?!exp) 匹配后面不是exp的位置 (? 匹配前面不是exp的位置 *? 重复任意次，但尽可能少重复 a.ba.?b 将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串 +? 重复1次或多次，但尽可能少重复 ?? 重复0次或1次，但尽可能少重复 {M,N}? 重复M到N次，但尽可能少重复 {M,}? 重复M次以上，但尽可能少重复 re模块Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。 函数 说明 compile(pattern, flags=0) 编译正则表达式返回正则表达式对象 match(pattern, string, flags=0) 用正则表达式匹配字符串 成功返回匹配对象 否则返回None search(pattern, string, flags=0) 搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None split(pattern, string, maxsplit=0, flags=0) 用正则表达式指定的模式分隔符拆分字符串 返回列表 sub(pattern, repl, string, count=0, flags=0) 用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数 fullmatch(pattern, string, flags=0) match函数的完全匹配（从字符串开头到结尾）版本 findall(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回字符串的列表 finditer(pattern, string, flags=0) 查找字符串所有与正则表达式匹配的模式 返回一个迭代器 purge() 清除隐式编译的正则表达式的缓存 re.I / re.IGNORECASE 忽略大小写匹配标记 re.M / re.MULTILINE 多行匹配标记","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://alexyanglong.github.io/tags/正则表达式/"},{"name":"re模块","slug":"re模块","permalink":"http://alexyanglong.github.io/tags/re模块/"}]},{"title":"Python基础（11）——面向对象基础","slug":"Python基础（11）——面向对象基础","date":"2018-04-11T16:00:00.000Z","updated":"2018-06-05T02:04:09.104Z","comments":true,"path":"2018/04/12/Python基础（11）——面向对象基础/","link":"","permalink":"http://alexyanglong.github.io/2018/04/12/Python基础（11）——面向对象基础/","excerpt":"","text":"Python基础（11）——面向对象基础在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 面向对象的三个基本特征是：封装、继承、多态。 封装封装是实现面向对象程序设计的第一步，封装就是将数据或函数等集合在一个个的单元中（我们称之为类）。被封装的对象通常被称为抽象数据类型。 隐藏复杂的现实细节，暴露简单的调用接口。 封装的意义：封装的意义在于保护或者防止代码（数据）被我们无意中破坏。在面向对象程序设计中数据被看作是一个中心的元素并且和使用它的函数结合的很密切，从而保护它不被其它的函数意外的修改。 ​ 1、保护数据成员，不让类以外的程序直接访问或修改，只能通过提供的公共的接口访问==&gt;数据封装。 ​ 2、方法的细节对用户是隐藏的，只要接口不变，内容的修改不会影响到外部的调用者==&gt;方法封装。 ​ 3、当对象含有完整的属性和与之对应的方法时称为封装。 ​ 4、从对象外面不能直接访问对象的属性，只能通过和该属性对应的方法访问。 ​ 5、对象的方法可以接收对象外面的消息。 继承从已有的类创建新类的过程 提供继承信息的称为父类(超类/基类) 得到继承信息的称为子类(派生类)。继承主要实现重用代码，节省开发时间。 ​ 1、在类名后边的括号里一般写的是基类的类名 ​ 2、子类中继承自父类(基类),则父类的成员属性和成员方法都可以被子类所继承 ​ 3、父类中私有的成员属性不能继承给子类的 多态“一个接口，多种表现形式”。 同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。 多态的三个条件: ​ 1、继承的存在(继承是多态的基础,没有继承就没有多态) ​ 2、子类重写父类的方法(多态下调用子类重写的方法) ​ 3、父类引用变量指向子类对象(子类到父类的类型转换) 数据抽象 一 找到和对象相关的数据——属性( 名词），可以使用包装器@property和修改器@属性.setter来装饰属性。 __slots__限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。 123class Person(object): # 限定Person对象只能绑定_name, _age和_gender属性 __slots__ = (&apos;_name&apos;, &apos;_age&apos;, &apos;_gender&apos;) 行为抽象 一 找到和对象相关的行为——方法（动词） 成员方法：第一个参数为self，由实例化的对象调用 类方法：使用@classmethod装饰的方法是类方法，与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） 静态方法：使用@staticmethod装饰的方法是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 魔法方法：__init__() 、__del__() 、__str__() 、__repr__()","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://alexyanglong.github.io/tags/面向对象/"}]},{"title":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO","slug":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO","date":"2018-04-09T16:00:00.000Z","updated":"2018-06-05T02:03:55.453Z","comments":true,"path":"2018/04/10/Python基础（10）——文件IO、异常处理、StringIO、BytesIO/","link":"","permalink":"http://alexyanglong.github.io/2018/04/10/Python基础（10）——文件IO、异常处理、StringIO、BytesIO/","excerpt":"","text":"Python基础（10）——文件IO、异常处理、StringIO、BytesIO文件IOIO操作，使用open() 函数，还可以使用with上下文关键字来确保打开的文件操作符在退出时被关闭。 12with open(path, mode [, encoding]) as f: 操作... f.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。f.write() 写文件 # 如果要写入字符串以外的数据,先将他转换为字符串f.close() 关闭文件f.readline([size]) 读取整行内容,包括\\n字符, 如果给定参数则从文件开始读取指定的字符个数f.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。f.tell() 返回一个整数,表示当前文件指针的位置(就是到文件头的比特数).f.seek(偏移量,[起始位置]) 用来移动文件指针 #偏移量:单位:比特,可正可负起始位置:0-文件头,默认值;1-当前位置;2-文件尾 mode模式： open()函数的mode方式详解 os模块12345678910111213141516import osos.getcwd() # 返回当前的工作目录 # 获取绝对路径os.listdir(path) # 返回指定的文件夹包含的文件或文件夹的名字的列表os.mkdir(path) # 在当前目录下创建新的目录os.rmdir(path) # 删除目录, 只能删除空目录os.rename(src, dst) # 对文件进行重命名os.stat(file) # 获取文件属性os.remove(file) # 删除文件 #可以将本文件删除os.path.join(path1, path2) # 路径拼接os.path.split(path) # 拆分路径 # 返回一个元组(目录, 最后一个文件/目录名称)os.path.splitext(path) # 获取文件的或站名os.path.exists(path) # 判断文件/目录是否存在os.path.isfile(path) # 判断是否是文件os.path.getsize(file) # 获取文件的大小os.path.dirname(path) # 获取当前文件的目录os.path.basename(path) # 获取当前文件/目录名 异常处理在Python中处理异常使用try...except...[else...][finally...]关键字。 格式： 1234567891011try: try语句except 异常类1 as 变量1: 异常处理语句1except 异常类2 as 变量2: 异常处理语句2...[else: else语句][finally: finally语句] 执行顺序：进入try语句块，如果发生错误，依次匹配except中的异常类，匹配成功进入该异常处理块，如果不报错，会执行else中的语句，而finally不管有没有报错都会执行… 1234567891011121314151617def div(x , y): try: res = x / y except ZeroDivisionError as e: print('除数不能为0') else: print(res) finally: print('Anyway，I always run') def main(): div(10, 0)if __name__ == '__main__': main() StringIO很多时候，数据读写不一定是文件，也可以在内存中读写，而且更快。 StringIO模块主要用于在内存缓冲区中读写数据。它只有一个StringIO类，所以它的可用方法都在类中。此类中的大部分函数都与对文件的操作方法类似。 123456789101112&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write('hello')5&gt;&gt;&gt; f.write(' ')1&gt;&gt;&gt; f.write('world!')6&gt;&gt;&gt; print(f.getvalue())hello world!# getvalue() 方法用于获得写入后的str。 BytesIOStringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，先创建一个BytesIO对象，然后写入一些bytes。 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write('中文'.encode('utf-8'))6&gt;&gt;&gt; print(f.getvalue())b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"文件IO","slug":"文件IO","permalink":"http://alexyanglong.github.io/tags/文件IO/"},{"name":"异常处理","slug":"异常处理","permalink":"http://alexyanglong.github.io/tags/异常处理/"},{"name":"StringIO","slug":"StringIO","permalink":"http://alexyanglong.github.io/tags/StringIO/"},{"name":"BytesIO","slug":"BytesIO","permalink":"http://alexyanglong.github.io/tags/BytesIO/"}]},{"title":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域","slug":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域","date":"2018-04-07T16:00:00.000Z","updated":"2018-06-05T02:03:30.427Z","comments":true,"path":"2018/04/08/Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域/","link":"","permalink":"http://alexyanglong.github.io/2018/04/08/Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域/","excerpt":"","text":"Python基础（9）——函数、装饰器、迭代器、生成器、变量作用域函数定义函数，使用 def 关键字。 结构： 123def 函数名(参数列表...): 语句... return 返回值... 函数的参数： 1、不定长参数： *args 2、关键字参数：**kwargs 匿名函数: 关键字 lambda eg：qm = lambda x: x ** x 偏函数: 导入模块 import functools ​ functools.partical()就是创建一个新的函数，不需要自行定义函数，直接将结果赋值给一个变量，而这个变量就是一个函数。这个函数的目的是将默认参数给固定住。 回调函数：定义函数时，将函数名作为参数传递过来，然后在函数里边再次调用函数。 常用函数： abs(): 返回数字的绝对值max(): 返回给定参数中的最大值min():返回给定参数中最小的值pow(): 求幂(求次方) [求3^4 —&gt; print(3**4) 、 print(pow(3, 4))]round():四舍五入,如果只有一个参数,默认不保留小数点.参数二: 小数点后保留的位数 import mathmath.ceil():向上取整math.floor():向下取整math.sqrt():求开方math.modf():返回参数的整数部分和小数部分 import randomrandom.choice():返回列表,元祖,字典中的某一个值random.choices():返回列表,元祖,字典中的指定个数值个值 k 关键字参数random.random():返回0-1之间的数, [0, 1)random.uniform():返回指定的一个区间范围的随机数 [, )random.randint():返回指定区间范围的随机整数 [, ]random.shuffle():将列表中的数据进行打乱排序 import time time.localtime() 获取本地时间time.asctime() / time.ctime() 将时间转换成用户可读时间, 返回str格式 (Thu Apr 19 23:02:35 2018)time.strftime(&#39;%Y-%m-%d %X&#39;) 字符串的格式化输出, 返回str格式 (2018-04-19 23:07:51)time.strptime(timeObject, &#39;%Y-%m-%d %X&#39;) 将字符串的时间格式转换成元祖类型的时间格式 import datetime datetime.datetime.now() 获取当前时间datetime.datetime(2020, 2, 2, 20, 20, 20) 获取指定的时间date1.strftime(&#39;%Y-%m-%d %X&#39;) 时间字符串的格式化输出, 返回str格式 import calendar calendar.month(2018, 4) 获取指定的月份日历calendar.calendar(2018) 获取指定的年份日历 装饰器本质还是函数（闭包函数）， 一般使用装饰器来装饰其他函数。本身还是函数的调用。 12345678910111213141516171819202122232425\"\"\"装饰器:1.在定义函数时,将函数名作为参数来传递2.自定义一个装饰器,(即自定义一个函数),在函数内部去调用真正的函数3.return 装饰器的自调\"\"\"def outer(func): def inner(): print('装饰器....') func() print('啦啦啦....') return inner@outer # --&gt; func1 = outer(func1)def func1(): print('1234567')func1()\"\"\"输出：装饰器....1234567啦啦啦....\"\"\" 例如 @property 、@属性名.setter 广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查，这样，程序运行时就减少了出错的可能性。 迭代器迭代器是一个可以记住遍历的位置的对象。 迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。 迭代器有两个基本的方法：__iter()__ 和 next()。 字符串，列表或元组对象都可用于创建迭代器。 生成器yield 函数被称为生成器（generator），生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器， 每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。调用一个生成器函数，返回的是一个迭代器对象。 变量作用域（LEGB）L （Local） 局部作用域 E （Enclosing） 嵌套作用域，闭包函数外的函数中 G （Global） 全局作用域 B （Built-in） 内建作用域","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"函数","slug":"函数","permalink":"http://alexyanglong.github.io/tags/函数/"},{"name":"装饰器","slug":"装饰器","permalink":"http://alexyanglong.github.io/tags/装饰器/"},{"name":"迭代器","slug":"迭代器","permalink":"http://alexyanglong.github.io/tags/迭代器/"},{"name":"生成器","slug":"生成器","permalink":"http://alexyanglong.github.io/tags/生成器/"},{"name":"变量作用域","slug":"变量作用域","permalink":"http://alexyanglong.github.io/tags/变量作用域/"}]},{"title":"Python基础（8）——常见的字符串函数","slug":"Python基础（8）——常见的字符串函数","date":"2018-04-04T16:00:00.000Z","updated":"2018-06-05T02:03:08.617Z","comments":true,"path":"2018/04/05/Python基础（8）——常见的字符串函数/","link":"","permalink":"http://alexyanglong.github.io/2018/04/05/Python基础（8）——常见的字符串函数/","excerpt":"","text":"常见的字符串函数1、splitsplit(str=’ ‘[,num]) 对字符串进行切片，并返回一个列表，str 表示按此字符串进行分割，默认是空格，num 表示最多分割多少次 12str1 = 'aaa sss ddd 'print(str1.split(' ', 3)) # ['aaa', 'sss', 'ddd', ''] 2、splitlinessplitlines([keepends=False]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符，默认是False 123456str2 = '''aaaaaaaaaassssssssssssssssssdddddddd'''print(str2.splitlines(keepends=True)) # ['aaaaaaaaaa\\n', 'ssssssssssssssssss\\n', 'dddddddd\\n']print(str2.splitlines(keepends=False)) # ['aaaaaaaaaa', 'ssssssssssssssssss', 'dddddddd'] 3、joinjoin() 用于将序列中的元素以指定的字符连接生成一个新的字符串 1234str3 = 'asdfghj'list = ['a','s','e']print('-'.join(list)) # 'a-s-e'print('-'.join(str3)) # 'a-s-d-f-g-h-j' 4、maxmax() 返回给定参数的最大ASCII值的字符，参数可以为序列 1print(max('asdfghj')) # 's' 5、minmax() 返回字符串中最小ASCII值的字符 1print(min('asdfghj')) # 'a' 6、replacereplace(old, new[, max]) 把字符串中的 old（旧字符串） 替换成 new(新字符串)，如果指定第三个参数max，则替换不超过 max 次 1print('asdfghjkasasas'.replace('a', '1', 2)) # '1sdfghjk1sasas' 7、maketrans、translatemaketrans() 返回字符串转换后生成的新字符串 translate(table) 返回按照table中给出的映射来进行翻译后的字符串 12trantab = str.maketrans('abcd', '1234')print('asdfghjkasasas'.translate(trantab)) # '1s4fghjk1s1s1s' 8、startswith startswith(str, beg=0,end=len(string)) 方法用于检查字符串是否是以指定子字符串开头，如果是则返回 True，否则返回 False。如果参数 beg 和 end 指定值，则在指定范围内检查 12print('asdfghjkasasas'.startswith('asd')) # Trueprint('asdfghjkasasas'.startswith('asd', 2, 10)) # False 9、endswithendswith(suffix[, start[, end]]):方法用于判断字符串是否以指定后缀结尾，如果以指定后缀结尾返回True，否则返回False。可选参数”start”与”end”为检索字符串的开始与结束位置 1print('asdfghjkasasas'.endswith('ghj', 0, 7)) # True 10、encodeencode() 指定的编码格式编码字符串。默认编码为 ‘utf-8’。 1print('asdfg'.encode('utf-8')) # b'asdfg' 11、decodedecode():以指定的编码格式解码 bytes 对象。默认编码为 ‘utf-8’。 1print(('asdfg'.encode('utf-8')).decode('utf-8')) # 'asdfg' 12、isalphaisalpha():方法检测字符串是否只由字母组成 1print('asdfg12'.isalpha()) # False 13、isalnumisalnum():检测字符串是否由字母和数字组成 1print('123456asd'.isalnum()) # True 14、isupperisupper():检测字符串中所有的字母是否都为大写 1print('ASDFGd'.isupper()) # False 15、islowerislower():检测字符串是否由小写字母组成 1print('Asdfghjkrt5'.islower()) # False 16、istitleistitle():检测字符串中所有的单词拼写首字母是否为大写，且其他字母为小写 1print('My Name Is Alex'.istitle()) # True 17、isdigitisdigit():检测字符串是否只由数字组成 1print('12345678'.isdigit()) # True 18、isnumericisnumeric():检测字符串是否只由数字组成。这种方法是只针对unicode对象 1print('1234567'.isnumeric()) # True 19、isdecimalisdecimal():检查字符串是否只包含十进制字符。这种方法只存在于unicode对象 1print('12345'.isdecimal()) # True 20、isspaceisspace():检测字符串是否只由空白字符组成 1print(' '.isspace()) # True 21、lenlen():返回对象（字符、列表、元组等）长度或项目个数 1print(len('asdfghj234567')) # 13 22、lowerlower():转换字符串中所有大写字符为小写 1print('ASDasdfgerty3456'.lower()) # 'asdasdfgerty3456' 23、upperupper():将字符串中的小写字母转为大写字母 1print('ASDasdfgerty3456'.upper()) # 'ASDASDFGERTY3456' 24、swapcaseswapcase():用于对字符串的大小写字母进行转换 1print('ASDasdfgerty3456'.swapcase()) # 'asdASDFGERTY3456' 25、capitalizecapitalize():将字符串的第一个字母变成大写,其他字母变小写 1print('asd WERtsd3456'.capitalize()) # 'Asd wertsd3456' 26、titletitle():返回”标题化”的字符串,就是说所有单词都是以大写开始 1print('my name is Alex'.title()) # 'My Name Is Alex' 27、centercenter(width[, fillchar]):返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格 1print('asd1'.center(10, ' ')) # ' asd1 ' 28、ljustljust(width[, fillchar]):返回一个原字符串左对齐,并使用fillchar填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符串 1print('asd1'.ljust(10, ' ')) # 'asd1 ' 29、rjustrjust(width[, fillchar]):回一个原字符串右对齐,并使用fillchar填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串 1print('asd1'.rjust(10, ' ')) # ' asd1' 30、zfillzfill(width):返回指定长度的字符串，原字符串右对齐，前面填充0 1print('asd1'.zfill(10)) # '000000asd1' 31、countcount():统计字符串里某个字符出现的次数。可选参数为在字符串搜索的开始与结束位置 1print('aaaaaaaqwertya'.count('a')) # 8 32、findfind():方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，如果指定范围内如果包含指定子字符串，返回的是子字符串在字符串中的起始位置（下标）。如果不包含，返回-1 1print('asdfghjkl'.find('fg1')) # -1 33、rfindrfind():返回字符串最后一次出现的位置（下标），如果没有匹配项则返回-1 1print('asdfghjklfg'.rfind('fg')) # 9 34、indexindex():方法检测字符串中是否包含子字符串 str ，如果指定 beg（开始） 和 end（结束） 范围，则检查是否包含在指定范围内，该方法与 python find()方法相似，但是没有匹配项时，报错。 12print('asdfghjkl'.index('fg')) # 3print('asdfghjkl'.index('fg1')) # ValueError: substring not found 35、rindexrindex():返回子字符串 str 在字符串中最后出现的位置（下标），该方法与 python rfind()方法相似，但是没有匹配项时，报错。 12print('asdfghjklfg'.rindex('fg')) # 9print('asdfghjkl'.rindex('fg1')) # ValueError: substring not found 36、stripstrip():用于移除字符串头尾指定的字符（默认为空格） 1print(' asd '.strip()) # 'asd' 37、lstriplstrip():方法用于截掉字符串左边的空格或指定字符（默认为空格） 1print(' asd '.lstrip()) # 'asd ' 38、rstriprstrip():删除 string 字符串末尾的指定字符（默认为空格） 1print(' asd '.rstrip()) # ' asd'","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"字符串函数","slug":"字符串函数","permalink":"http://alexyanglong.github.io/tags/字符串函数/"}]},{"title":"Python基础（7）——流程控制：分支与循环","slug":"Python基础（7）——流程控制：分支与循环","date":"2018-04-02T16:00:00.000Z","updated":"2018-06-05T02:02:22.284Z","comments":true,"path":"2018/04/03/Python基础（7）——流程控制：分支与循环/","link":"","permalink":"http://alexyanglong.github.io/2018/04/03/Python基础（7）——流程控制：分支与循环/","excerpt":"","text":"流程控制：分支与循环流程控制语句主要分为三种： ​ 1、顺序语句：顾名思义，就是按照顺序从头一句一句往下执行。 ​ 2、分支语句 ​ 3、循环语句 分支语句在Python中，要构造分支结构可以使用if、elif和else关键字。 结构： 1234567if 表达式1: 语句1elif 表达式2: 语句2[...]else: 语句n 执行顺序：先判断表达式1 的值，如果为True ，则执行语句1 ，然后结束分支。如果为False ，则判断表达式2 的值，如果为True ，则执行语句2 ，然后结束分支。[…] 如果所有的表达式都为False ，则执行else中的语句n 。 练习：英制单位与公制单位互换 12345678value = float(input('请输入长度:'))unit = input('请输入单位:')if unit == 'in' or unit == '英寸': print('%f英寸 = %f厘米' % (value, value * 2.54))elif unit == 'cm' or unit == '厘米': print('%f厘米 = %f英寸' % (value, value / 2.54))else: print('请输入有效的单位') 循环语句构造循环语句要使用 for...in... 或者 while 关键字。 1、for...in...结构，依次把可迭代容器中的每个元素迭代出来 12for 变量 in 可迭代容器: 语句... eg：求1-100的和 1234sum = 0for x in range(101): sum += xprint(sum) 2、while结构，只要条件满足，就不断循环，条件不满足时退出循环。 12while 表达式： 语句... eg：猜数字游戏 ​ 规则：计算机出一个1~100之间的随机数由人来猜​ 计算机根据人猜的数字分别给出提示大一点/小一点/猜对了，当猜的次数大于7，再提示智商不足 1234567891011121314151617import randomanswer = random.randint(1, 100)counter = 0while True: counter += 1 number = int(input('请输入:')) if number &lt; answer: print('大一点') elif number &gt; answer: print('小一点') else: print('恭喜你猜对了!') breakprint('你总共猜了%d次' % counter)if counter &gt; 7: print('你的智商余额明显不足') 练习：打印九九乘法表，要使用双层循环 1234for i in range(1, 10): for j in range(1, i + 1): print('%d*%d=%d' % (i, j, i * j), end='\\t') print()","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"分支循环","slug":"分支循环","permalink":"http://alexyanglong.github.io/tags/分支循环/"}]},{"title":"Python基础（6）——list、tuple、dict、set之间的转换","slug":"Python基础（6）——list、tuple、dict、set之间的转换","date":"2018-04-01T16:00:00.000Z","updated":"2018-06-05T02:02:01.305Z","comments":true,"path":"2018/04/02/Python基础（6）——list、tuple、dict、set之间的转换/","link":"","permalink":"http://alexyanglong.github.io/2018/04/02/Python基础（6）——list、tuple、dict、set之间的转换/","excerpt":"","text":"Python基础（6）——list、tuple、dict与set之间的转换list、tuple、dict与set之间的转换list和tuple是有序的，dict和set是无序的。 list和dict是可变的，tuple和set是“不可变的”。 dict具有极快的查找速度，不会因为元素个数的增多而变慢，相应的，占用的空间大； 而list占用的空间较小，但是查找速度会随着元素个数的增多而变慢。 12345678910111213141516171819202122232425262728293031323334#list-&gt;setlist1 = [1, 2, 3, 4, 4, 5, 5]set1 = set(list1)print(set1)print(type(set1))# set-&gt;listset2 = &#123;1, 2, 3, 4, 5, 6&#125;list2 = list(set2)print(list2)print(type(list2))# tuple-&gt;settuple1 = (1, 2, 3, 4, 5, 6, 6, 6)set3 = set(tuple1)print(set3)print(type(set3))# set-&gt;tupleset4 = &#123;1, 2, 3, 4, 5, 6&#125;tuple2 = tuple(set4)print(tuple2)print(type(tuple2))# dict-&gt;setdict1 = &#123;'Alex': 88, 'xiaoming' : 99, 'Ala': 96, 'Tom': 85, 'Jhon': 77&#125;set5 = set(dict1)print(set5)print(type(set5))# set-dict 注意：set不能转换成dict，因为set只有key，而dict是key-value形式存储的# set6 = &#123;2, 3, 4, 5&#125;# dict2 = dict(set6)# print(dict2)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"list","slug":"list","permalink":"http://alexyanglong.github.io/tags/list/"},{"name":"tuple","slug":"tuple","permalink":"http://alexyanglong.github.io/tags/tuple/"},{"name":"dict","slug":"dict","permalink":"http://alexyanglong.github.io/tags/dict/"},{"name":"set","slug":"set","permalink":"http://alexyanglong.github.io/tags/set/"}]},{"title":"Python基础（5）——集合set","slug":"Python基础（5）——集合set","date":"2018-04-01T16:00:00.000Z","updated":"2018-06-05T02:01:41.712Z","comments":true,"path":"2018/04/02/Python基础（5）——集合set/","link":"","permalink":"http://alexyanglong.github.io/2018/04/02/Python基础（5）——集合set/","excerpt":"","text":"Python基础（5）——集合set集合setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 作用: 一般是对list ，tuple中的元素进行去重的，求交集、并集、差集等 set的一些常用操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# 获得setset1 = set([1, 2, 2, 3, 3, 3])print(set1)print(type(set1))set2 = set((1, 2, 3, 1, 2, 3, 4, 5))print(set2)print(type(set2))set3 = set(&#123;3, 4, 5, 5, 6, 3, 7&#125;)print(set3)print(type(set3))# 添加set4 = set([1, 2, 2, 3, 3, 3])set4.add(55) # add() #可以添加重复的值,但是没效果# set4.add([10, 9]) #直接报错,不能添加listset4.add((10, 9))# set4.add(&#123;'a':1&#125;) #直接报错,不能添加字典# 总结:list和dict是可改变的, 而tuple是不可改变print(set4)# 修改set5 = set([1, 2, 3, 4, 5])# 将list dict tuple 等等整个插入进去set5.update([6, 7, 8])set5.update(&#123;9 : 'a', 10 : 'b'&#125;) #注意：插入字典时，是将key插进去set5.update((11, 56))print(set5)# 删除set6= set([1, 2, 3, 4, 5])set6.remove(4)print(set6)# 遍历set7 = set((231, 323.14, 'asddf', None, True))for i in set7: print(i)# 交集 &amp; 并集 | 差集 - 对称差 ^set8 = set([1, 2, 3, 4])set9 = set([3, 4, 5, 6])set10 = set8 &amp; set9set11 = set8 | set9print(set10)print(type(set10))print(set11)print(type(set11))","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"set","slug":"set","permalink":"http://alexyanglong.github.io/tags/set/"}]},{"title":"Python基础（4）——字典dict","slug":"Python基础（4）——字典dict","date":"2018-03-31T16:00:00.000Z","updated":"2018-06-05T02:01:22.483Z","comments":true,"path":"2018/04/01/Python基础（4）——字典dict/","link":"","permalink":"http://alexyanglong.github.io/2018/04/01/Python基础（4）——字典dict/","excerpt":"","text":"Python基础（4）——字典dict字典dictPython内置了字典：dict的支持，dict全称dictionary，使用键-值（key-value）存储，具有极快的查找速度。 注意事项:​ 1、在字典中键(key)的值必须是唯一​ 2、在字典中可以存放多个键值对​ 3、在字典中键(key)必须是不可变类型，字符串 、整数等都可以作为键(key) 下面是字典dict的一些常用操作： 12345678910111213141516171819202122232425262728293031323334# 定义字典dict1 = &#123;'Alex': 88, 'xiaoming' : 99, 'Ala': 96, 'Tom': 85, 'Jhon': 77&#125;print(dict1)# 元素的访问# 获取的方式: 字典名[key]print(dict1['xiaoming'])print(dict1.get('Alex'))# 添加元素dict1['HanMeimei'] = 89print(dict1)# 修改dict1['HanMeimei'] = '90'print(dict1)# 删除dict1.pop('HanMeimei')print(dict1)# 遍历for k in dict1: print(k, dict1[k])# 获取字典所有的value和keyprint(dict1.values())print(dict1.keys())# 遍历value值for v in dict1.values(): print(v)#遍历key值for k in dict1.keys(): print(k)#遍历key-value值for k,v in dict1.items(): print(k, v)for k,v in enumerate(dict1): print(k, v)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"dict","slug":"dict","permalink":"http://alexyanglong.github.io/tags/dict/"}]},{"title":"Python基础（3）——元组tuple","slug":"Python基础（3）——元组tuple","date":"2018-03-30T16:00:00.000Z","updated":"2018-06-05T02:01:03.102Z","comments":true,"path":"2018/03/31/Python基础（3）——元组tuple/","link":"","permalink":"http://alexyanglong.github.io/2018/03/31/Python基础（3）——元组tuple/","excerpt":"","text":"Python基础（3）——元组tuple元组tuplePython还有另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。 下面是元组tuple的一些常见操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# 创建一个空元祖tuple1 = ()print(tuple1)print(type(tuple1))# tuple和list一样也可以保存任意数据类型的数据tuple2 = (231, 323.14, 'asddf', None, True)print(tuple2)# 注意：当创建的元组只有一个元素时，需要在元素后面加一个逗号tuple3 = (34, ) # ===&gt; tuple类型 # tuple3 = (34) # ===&gt; int类型print(tuple3)# 获取元组的元素和list一样，通过下标来获取tuple4 = (1, 2, 3, 4, 5, 6)print(tuple4[-1])# 注意：元组定义好之后是不能修改的tuple5 = (1, 2, 3, 4, [11, 22, 33])# tuple5[0] = 150 # 报错print(tuple5[-1][-2]) # ==&gt; print(tuple5[4][1])# 元组进行操作# 将两个元组合并成一个新的元组tuple7 = (1, 2, 3)tuple8 = (4, 5, 6)tuple9 = tuple7 + tuple8print(tuple9)print(tuple7, tuple8)# 将元组重复n次,最后返回一个新的元组tuple10 = (1, 2, 3)print(tuple10 * 3)# in 判断一个元素是否在一个元组中,如果在返回True,否则返回Falsetuple11 = (3, 5, 7)print(3 in tuple11)print(4 in tuple11)# 元组的截取# 格式: 元组名[start:end:step]tuple12 = (1, 2, 3, 4, 5, 6, 7, 8, 9,10)print(tuple12[2:5])print(tuple12[3:])print(tuple12[:3])# 将元组进行逆序排列print(tuple12[::-1])# 二维元组tuple13 = ((2, 3, 4), (5, 6, 7))print(tuple13)print(tuple13[1][1])# 元组的方法# len(): 求一个元组的长度tuple14 = (1, 2, 3, 4, 5)print(len(tuple14))# max(): 求一个元组的元素的最大值print(max(tuple14))# min(): 求一个元组的元素的最小值print(min(tuple14))#遍历for i in tuple14: print(i)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"tuple","slug":"tuple","permalink":"http://alexyanglong.github.io/tags/tuple/"}]},{"title":"Python基础（2）——列表list","slug":"Python基础（2）——列表list","date":"2018-03-29T16:00:00.000Z","updated":"2018-06-05T02:00:33.285Z","comments":true,"path":"2018/03/30/Python基础（2）——列表list/","link":"","permalink":"http://alexyanglong.github.io/2018/03/30/Python基础（2）——列表list/","excerpt":"","text":"Python基础（2）——列表list列表listPython还内置了一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 下面是列表list的一些常见操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106# 创建一个空列表list1 = []print(list1)print(type(list1))# 创建带有元素的列表list2 = [1, 2, 3, 4, 5, 6, 7, 8]print(list2)# 列表元素的类型可以不同list3 = [12, 'qwe', 0.87, False, None]print(list3)# 访问列表中的元素 格式: 列表名[元素的下标] 注意：下标不能超出列表的范围，最大为len(list)-1，超出下标会报一个IndexError错误list4 = [1, 2, 3, 4, 5, 6, 7, 8]print(list4[5])# 修改元素list4[3] = 10print(list4)# 列表的操作# 列表拼接list5 = [1, 2, 3, 4]list6 = [5, 6, 7]list7 = list5 + list6print(list7)# 列表的重复list8 = [4, 5, 6]print(list8 * 3)# 判断一个元素是否在列表中list9 = [1, 2, 3, 4, 5, 6]# 返回的结果是布尔值 存在为True 不存在为Falseprint(7 in list9)print(4 in list9)# 截取列表 list[start:end:step]list10 = [1, 2, 3, 4, 5, 6, 7, 8]print(list10[:6]) # 从左截取，从头开始，到下标为5的元素print(list10[5:]) # 从左截取，从下标为5的元素，到末尾print(list10[::-1]) # 将list倒序排列print(list10[::-2]) # 从右截取，末尾开始，每隔一个元素截取一个# 二维列表list11 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]# 获取元素print(list11[0][0])# 列表的方法# append(): 在列表的末尾添加一个元素list1 = [1, 2, 3, 4, 5, 6]list1.append(8)print(list1)list1.append([7, 9, 10])print(list1)# extend(): 在列表的末尾一次性追加另外一个列表中的多个值list2 = [1, 2, 3, 4, 5, 6]list2.extend([200, 300, 400])print(list2)#insert(index, val):在指定下标处添加一个元素,原来此处的元素往后移动 index：表示列表下标，val：表示下标对应的值list3 = [1, 2, 3, 4]list3.insert(1, 250)print(list3)# pop([index]):将列表中指定下标的元素删除, 如果不传递参数,则删除的是最后一个元素 index：表示列表下标，返回值：删除的该元素list4 = [1, 2, 3, 4, 5, 6]print(list4.pop())list4.pop()print(list4)list4.pop(1)print(list4)# remove(val): 移除列表中指定的元素，从左开始，移除第一个 val：表示列表中的值list5 = [3, 4, 5, 6, 3, 7]list5.remove(3)# list5.remove(3)print(list5)# clear(): 清除列表中所有的元素list6 = [1, 2, 3, 4, 5, 6]list6.clear()print(list6)# index(val): 获取列表中该元素所对应的下标 val：列表中的某一个元素 返回值：列表中元素所对应的下标list7 = [1, 2, 3, 4, 5, 6]index1 = list7.index(3)print(index1)# len(list): 获取列表的长度print(len([1, 2, 3, 4, 5, 6]))# max(list): 获取列表中的最大值print(max([1, 2, 3, 4, 5, 6]))# min(list): 获取列表中的最小值print(min([1, 2, 3, 4, 5, 6]))# count(val): 计算列表中元素出现的次数 val：列表中的某一个元素list8 = [1, 3, 4, 3, 3, 3, 3, 6, 7]print(list8.count(3))# reverse(): 将列表进行倒序排列list9 = [1, 2, 3, 4, 5, 10, 7, 8, 9]list9.reverse()print(list9)# sort(): 将列表中的元素进行升序排列list10 = [10, 90, 78, 23, 65, 43]list10.sort()print(list10)# enumerate(list[, start = 0]):将列表中元素和其对应的下标一一展示出来# list: 列表# start: [start = 下标值]list16 = list(enumerate(list15))list17 = list(enumerate(list15, start = 1))print(list16)print(list17)# 循环遍历for i, v in list16: print(i, v)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"list","slug":"list","permalink":"http://alexyanglong.github.io/tags/list/"}]},{"title":"Python基础（1）——数据类型与基础语法","slug":"Python基础（1）——数据类型与基础语法","date":"2018-03-27T16:00:00.000Z","updated":"2018-06-05T01:57:20.327Z","comments":true,"path":"2018/03/28/Python基础（1）——数据类型与基础语法/","link":"","permalink":"http://alexyanglong.github.io/2018/03/28/Python基础（1）——数据类型与基础语法/","excerpt":"","text":"Python基础（1）——数据类型与基础语法数据类型计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，部分如下： 整型（int）：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如0b100，换算成十进制是4）、八进制（如0o100，换算成十进制是64）、十进制（100）和十六进制（0x100，换算成十进制是256）的表示法。 浮点型（float）：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如123.456）之外还支持科学计数法（如1.23456e2）。 字符串型（str）：字符串是以单引号或双引号括起来的任意文本，比如&#39;hello&#39;和&quot;hello&quot;,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 布尔型（bool）：布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如3 &lt; 5会产生布尔值True，而2 == 1会产生布尔值False）。 空值类型（None）：表示变量的值为None。 复数型（complex）：形如3+5j，跟数学上的复数表示一样，唯一不同的是虚部的 i 换成了 j 。 数据类型之间的转换： int()：将一个数值或字符串转换成整数，可以指定进制。 float()：将一个字符串转换成浮点数。 str()：将指定的对象转换成字符串形式，可以指定编码。 chr()：将整数转换成该编码对应的字符串（一个字符）。 ord()：将字符串（一个字符）转换成对应的编码（整数）。 变量在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。 硬性规则： ​ 1、变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头； ​ 2、大小写敏感（小写的 a 和大写的 A 是两个不同的变量）； ​ 3、不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。 PEP 8要求： ​ 1、用小写字母拼写，多个单词用下划线连接； ​ 2、受保护的实例属性用单个下划线开头； ​ 3、私有的实例属性用两个下划线开头。 当然，给变量（标识符）命名做到见名知意也是非常重要的。 运算符与表达式 运算符优先级 赋值表达式： 变量 = 表达式 表达式为真的情况: not 0 -1 等为真 表达式为假的情况: 0 &#39;&#39; None False [] () {} 格式化输出Python中，在使用print()函数在进行打印输出时，可以format()和% 占位符格式化输出字符串。 常见的%占位符有： 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 12print('%2d-%02d' % (3, 1)) # --&gt; 3-01print('%.2f' % 3.1415926) # --&gt; 3.14 有些时候，字符串里面的%是一个普通字符，这个时候就需要转义，用%%来表示一个%： 1print('the rate: %d %%' % 7) # --&gt; the rate: 7 % 另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多： 1print('Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)) # Hello, 小明, 成绩提升了 17.1% 注释注释分为单行注释和多行注释。 单行注释直接在要注释的行前面加# 1# 这是一行单行注释 多行注释可以使用用&#39;&#39;&#39;或&quot;&quot;&quot;开头，&#39;&#39;&#39;或&quot;&quot;&quot;结尾 1234567891011'''这也是多行注释这也是多行注释...'''\"\"\"这里是多行注释这里是多行注释...\"\"\" 小练习1、将华氏温度转换为摄氏温度 F = 1.8 * C + 32，F表示华氏温度，C表示摄氏温度 123f = float(input('请输入华氏温度: '))c = (f - 32) / 1.8print('%.1f华氏度 = %.1f摄氏度' % (f, c)) 2、输入圆的半径计算计算周长和面积 1234567import mathradius = float(input('请输入圆的半径: '))perimeter = 2 * math.pi * radiusarea = math.pi * radius * radiusprint('周长: %.2f' % perimeter)print('面积: %.2f' % area) 3、输入年份判断是不是闰年，是则输出 True，否则输出 False 12345year = int(input('请输入年份: '))# 如果代码太长写成一行不便于阅读 可以使用\\或()折行is_leap = (year % 4 == 0 and year % 100 != 0 \\ or year % 400 == 0)print(is_leap)","categories":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://alexyanglong.github.io/tags/Python/"},{"name":"数据类型","slug":"数据类型","permalink":"http://alexyanglong.github.io/tags/数据类型/"},{"name":"基础语法","slug":"基础语法","permalink":"http://alexyanglong.github.io/tags/基础语法/"}]},{"title":"Hexo快速搭建静态Blog网站","slug":"Hexo快速搭建静态Blog网站","date":"2018-03-24T16:00:00.000Z","updated":"2018-06-05T02:19:37.517Z","comments":true,"path":"2018/03/25/Hexo快速搭建静态Blog网站/","link":"","permalink":"http://alexyanglong.github.io/2018/03/25/Hexo快速搭建静态Blog网站/","excerpt":"","text":"Hexo快速搭建静态Blog网站声明：以下所有操作都是在windows操作系统下进行。 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装在安装Hexo前需要确保电脑已经安装以下程序 : Node.js Git 这两个程序的安装很简单，windows用户可以使用安装程序进行安装，简单高效。 安装Node.js建议使用这个下载地址，找到合适的版本进行下载安装即可，安装时的操作请自行参考百度。 安装Git建议使用这个下载地址 进行下载安装, 这里也请参考百度。建议不要下载最新的版本, 尽量下载大多数人用的版本。 安装Hexo在安装Hexo前，请再次确保Node.js和Git已经成功安装。检查是否安装好以上两个程序，在桌面点击鼠标右键，可在选项中看到 Git Bash Here 选项，点击进入bash交互界面。 在打开bash交互界面（类似于Linux交互界面）中输入： 1$ git --version 1$ node --version 如果显示相关的版本信息说明安装成功。 现在可以正式安装Hexo了，使用如下命令安装： 1$ npm install -g hexo-cli 建站初始化安装 Hexo 完成后，执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt; # folder 是文件夹 即 hexo init 文件夹$ cd &lt;folder&gt;$ npm install 命令执行成功没有 error 错误，我们就建站成功了。 ###安装hexo-server并启动 12$ npm install hexo-server --save$ hexo server 这两条命令执行完成后会生成一个如下的地址： 本地hexo-web地址 把这个网址复制下来并粘贴到浏览器中打开即可看到本地 Hexo 默认的主题博客了，如果没有成功的话请检查自己是否有操作不当的地方或者命令错误。 部署创建Git仓库登录GitHub账号，创建一个仓库，注意仓库的名字一定要以 “&lt;用户名&gt;.github.io” 这种格式。 hexo2 创建时，注意要将下面这个选项勾上。 hexo3 生成SSH keys这个很重要！ 这个如果没有添加 ssh keys 那么等会必定会报错。 使用如下操作生成SSH key hexo4 生成密钥完成后， 将 id_rsa.pub 中的所有内容拷贝到github中相应的位置中去。 登录GitHub，找到如下位置： hexo5 hexo6 hexo7 将生成的在 id_rsa.pub 中的内容 拷贝到其中，然后添加。 更改配置在初始化文件夹下找到 _config.yml 这个文件并打开 1$ vim _config.yml 打开后做如下修改， repository 就是 github 为我们生成的一个地址。这里注意一下空格。 hexo8 生成静态网页并部署123$ hexo clean # 清理缓存$ npm install hexo-deployer-git --save$ hexo g -d 至此，部署完毕。 最后在浏览器中输入地址即可（即 username.github.io ，其中username为你自己创建仓库的名字）。 当然在以上操作中如果遇到什么错误 这里也许可以帮到你 帮助 。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://alexyanglong.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://alexyanglong.github.io/tags/Hexo/"}]}]}